% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{create_fractal_landscape}
\alias{create_fractal_landscape}
\title{Create Fractal Landscape with Spatial Autocorrelation}
\usage{
create_fractal_landscape(
  cells_per_row,
  cells_per_col = NULL,
  fractality,
  min_value = 0,
  max_value = 1,
  habitat_proportion = NULL,
  return_as_landscape_params = FALSE
)
}
\arguments{
\item{cells_per_row}{Integer. Number of cells per row (matrix rows). Must be positive.
Typical values: 10-100 for most simulations. Larger values increase resolution
but also memory requirements and computation time.}

\item{cells_per_col}{Integer. Number of cells per column (matrix columns). If NULL,
creates square landscape (cells_per_col = cells_per_row). Use different values
to create rectangular landscapes matching specific study regions.}

\item{fractality}{Numeric between 0 and 1. Controls degree of spatial autocorrelation
and clumping:
\itemize{
  \item **0.0-0.2**: Nearly random, little spatial structure. Isolated habitat cells
    scattered throughout matrix.
  \item **0.3-0.5**: Moderate clumping. Small habitat patches with some aggregation.
    Good for testing intermediate fragmentation scenarios.
  \item **0.6-0.7**: Strong clumping. Larger, more contiguous patches with clear
    spatial structure. Typical of many real landscapes.
  \item **0.8-1.0**: Very strong clumping. Large, highly aggregated patches or gradients.
    Useful for testing extreme fragmentation or strong environmental gradients.
}

Higher fractality → more smoothing iterations → stronger spatial autocorrelation.}

\item{min_value}{Numeric. Minimum habitat value for continuous landscapes.
Only used when habitat_proportion = NULL. Typically 0.0.}

\item{max_value}{Numeric. Maximum habitat value for continuous landscapes.
Only used when habitat_proportion = NULL. Must be > min_value. Typically 1.0.}

\item{habitat_proportion}{Numeric between 0 and 1, or NULL. Controls landscape type:
\itemize{
  \item **If provided**: Creates **binary** landscape (0/1, matrix/habitat).
    Value specifies proportion of cells designated as habitat (value = 1).
    Remaining cells become matrix (value = 0). Fractality determines spatial
    clustering of habitat cells.
  \item **If NULL**: Creates **continuous** landscape with values scaled to
    [min_value, max_value]. Represents smooth environmental gradients.
}}

\item{return_as_landscape_params}{Logical. Controls return format:
\itemize{
  \item **TRUE**: Returns \code{list(habitat = matrix)}, ready for direct use
    as landscape_params in \code{\link{twolife_simulation}}
  \item **FALSE**: Returns matrix only, for custom processing or visualization
}}
}
\value{
If \code{return_as_landscape_params = FALSE}:
  \itemize{
    \item Numeric matrix with dimensions \code{cells_per_row} × \code{cells_per_col}
    \item Values are either continuous ([min_value, max_value]) or binary (0, 1)
  }

  If \code{return_as_landscape_params = TRUE}:
  \itemize{
    \item List with component: \code{$habitat} (the generated landscape matrix)
    \item Compatible with \code{twolife_simulation(landscape_params = ...)}
  }
}
\description{
Generates spatially autocorrelated landscapes using iterative neighbor averaging,
a simplified fractal-like algorithm. Creates realistic habitat patterns with
controllable fragmentation and clustering. Supports both square and rectangular
landscapes, and can generate either continuous environmental gradients or
binary habitat/matrix patterns.
}
\details{
## Fractal Generation Algorithm

The function uses iterative neighbor averaging to create spatial autocorrelation:

**Step 1: Initialization**

Each cell \eqn{(i,j)} starts with random value:
\deqn{v_0(i,j) \sim \text{Uniform}(0, 1)}

**Step 2: Iterative Smoothing**

The algorithm performs \eqn{n_{\text{iter}}} smoothing iterations:

\deqn{n_{\text{iter}} = \text{round}(10 \times \text{fractality})}

At each iteration \eqn{t}, cell values are updated:

\deqn{v_{t+1}(i,j) = \alpha \cdot \bar{v}_t(i,j) + (1-\alpha) \cdot \varepsilon_{i,j}}

Where:
\itemize{
  \item \eqn{v_t(i,j)} = value at cell \eqn{(i,j)} at iteration \eqn{t}
  \item \eqn{\bar{v}_t(i,j)} = mean of 8-connected neighbors (Moore neighborhood):
    \deqn{\bar{v}_t(i,j) = \frac{1}{N_{\text{neighbors}}}\sum_{(i',j') \in N(i,j)} v_t(i',j')}
  \item \eqn{\alpha = 0.9} = smoothing weight (high value preserves spatial structure)
  \item \eqn{\varepsilon_{i,j} \sim \text{Uniform}(0,1)} = random noise (maintains variability)
  \item Edge cells use only available neighbors (\eqn{N_{\text{neighbors}} < 8})
}

**Step 3: Finalization**

After all iterations:

For **continuous landscapes** (habitat_proportion = NULL):
\deqn{v_{\text{final}}(i,j) = \text{min\_value} + v_n(i,j) \times (\text{max\_value} - \text{min\_value})}

For **binary landscapes** (habitat_proportion specified):
\itemize{
  \item Sort all cell values
  \item Set top \code{habitat_proportion} quantile to 1 (habitat)
  \item Set remaining cells to 0 (matrix)
  \item Result: spatially clustered binary pattern
}

## Spatial Autocorrelation

The iterative averaging creates spatial autocorrelation described by:

\deqn{\text{Cor}(v(i,j), v(i',j')) \approx \exp\left(-\frac{d}{\lambda}\right)}

Where:
\itemize{
  \item \eqn{d = \sqrt{(i-i')^2 + (j-j')^2}} = distance between cells
  \item \eqn{\lambda \propto \text{fractality}} = correlation length scale
  \item Higher fractality → larger \eqn{\lambda} → longer-range correlations → bigger patches
}

## Comparison to Other Methods

\tabular{llll}{
  \strong{Method} \tab \strong{Spatial Structure} \tab \strong{Computation} \tab \strong{Parameters} \cr
  This function \tab Moderate \tab Fast \tab Simple (fractality) \cr
  Midpoint displacement \tab Strong fractal \tab Medium \tab Hurst exponent \cr
  Random fields (NLMR) \tab Tunable \tab Slow \tab Multiple parameters \cr
  Percolation \tab Binary only \tab Fast \tab Threshold only \cr
}

Advantages of this method:
\itemize{
  \item Fast computation (suitable for parameter sweeps)
  \item Intuitive fractality parameter (0-1 scale)
  \item Supports both continuous and binary landscapes
  \item No external dependencies
}

## Parameter Selection Guidelines

**For habitat fragmentation studies:**
\itemize{
  \item Low fragmentation: fractality = 0.7-0.9, habitat_proportion = 0.5-0.7
  \item Medium fragmentation: fractality = 0.4-0.6, habitat_proportion = 0.3-0.5
  \item High fragmentation: fractality = 0.1-0.3, habitat_proportion = 0.2-0.4
}

**For environmental gradient studies:**
\itemize{
  \item Smooth gradients: fractality = 0.8-1.0, habitat_proportion = NULL
  \item Patchy gradients: fractality = 0.4-0.6, habitat_proportion = NULL
}

**For realistic landscapes:**
\itemize{
  \item Forest fragments: fractality = 0.5-0.7, habitat_proportion = 0.3-0.5
  \item Agricultural landscapes: fractality = 0.4-0.6, habitat_proportion = 0.4-0.6
  \item Urban-rural gradients: fractality = 0.6-0.8, continuous landscape
}

## Edge Effects

Cells at landscape edges have fewer neighbors, which can create slight edge artifacts:
\itemize{
  \item Effect is minor for most fractality values
  \item Becomes more noticeable at very high fractality (> 0.9)
  \item Use larger landscapes if edge effects are a concern
  \item Consider periodic boundary conditions in simulations if modeling infinite landscapes
}
}
\examples{
set.seed(100)
landscape1 <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  habitat_proportion = 0.6,
  return_as_landscape_params = TRUE
)
plot_landscape(landscape1, main = "Binary Habitat Landscape")
landscape2 <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  min_value = 0.35,
  max_value = 0.64,
  return_as_landscape_params = TRUE
)
plot_landscape(landscape2, main = "Continuous Gradient for Genetics")
print(landscape1)  # Binary habitat values
print(landscape2)  # Continuous range
}
\seealso{
\code{\link{plot_landscape}} for visualization,
  \code{\link{twolife_simulation}} for using landscapes in simulations,
  \code{\link{plot_simulation_on_landscape}} for overlaying simulation results
}
