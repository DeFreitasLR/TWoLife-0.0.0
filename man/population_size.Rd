% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{population_size}
\alias{population_size}
\title{Calculate Population Trajectory Over Time}
\usage{
population_size(result)
}
\arguments{
\item{result}{A 'twolife_result' object returned by \code{\link{twolife_simulation}}.
Must contain \code{$events$times} and \code{$events$types} components.}
}
\value{
A data frame with two columns:
  \describe{
    \item{time}{Numeric. Event times in chronological order (in simulation time units)}
    \item{population_size}{Integer. Population size at each event time, calculated
      as cumulative sum of demographic changes}
  }
}
\description{
Computes population size at each event time from simulation results by 
tracking the cumulative effects of demographic events. Essential for 
analyzing population dynamics, growth rates, extinction risk, and 
identifying critical demographic transitions. Compatible with all 
history_detail levels.
}
\details{
## Algorithm

Population size at time \eqn{t} is calculated using:

\deqn{N(t) = N_0 + \sum_{i=1}^{t} \Delta N_i}

Where:
\itemize{
  \item \eqn{N(t)} = population size at time t
  \item \eqn{N_0} = initial population size
  \item \eqn{\Delta N_i} = population change from event i
}

## Event Types and Population Change

Each event type contributes differently to \eqn{\Delta N}:

\itemize{
  \item **-1 (initial)**: \eqn{\Delta N = +1}. Records each founding individual
  \item **0 (death)**: \eqn{\Delta N = -1}. Mortality event
  \item **1 (birth)**: \eqn{\Delta N = +1}. Successful reproduction
  \item **2 (movement/dispersal)**: \eqn{\Delta N = 0}. Spatial redistribution only
  \item **3 (emigration)**: \eqn{\Delta N = -1}. Individual crosses absorbing boundary
}

## Boundary Condition Effects

Emigration events (type 3) only occur with **boundary_condition = 2** (absorbing):
\itemize{
  \item boundary_condition = 1 (reflective): Individuals bounce back, no emigration
  \item boundary_condition = 2 (absorbing): Crossing boundary causes emigration (\eqn{\Delta N = -1})
  \item boundary_condition = 3 (periodic): Individuals wrap around, no emigration
}

## Time Scaling

Event times follow the Gillespie algorithm (see \code{\link{twolife_simulation}} Details).
Time intervals between events are exponentially distributed with rate proportional 
to total demographic rates. Faster dynamics (higher birth/death rates) compress 
more events into less time.

## Analysis Applications

This function enables:
\itemize{
  \item **Population viability analysis**: Detect extinction times and probabilities
  \item **Growth rate estimation**: Calculate \eqn{r = \frac{1}{t}\log\frac{N(t)}{N_0}}
  \item **Demographic transitions**: Identify when population stabilizes or crashes
  \item **Density-dependent effects**: Compare trajectories with different density parameters
  \item **Animation frames**: Provides time points for \code{\link{snapshot_at_time}}
}
}
\examples{
set.seed(100)
landscape <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  habitat_proportion = 0.6,
  return_as_landscape_params = TRUE
)
landscape_genetic <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  min_value = 0.35,
  max_value = 0.64,
  return_as_landscape_params = TRUE
)
result <- twolife_simulation(
  landscape_params = landscape,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  simulation_params = list(max_events = 5),
  master_seed = 123
)
result_genetic <- twolife_simulation(
  landscape_params = landscape_genetic,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  genetic_params = list(
    genotype_means = rnorm(15, mean = 0.5, sd = 0.15),
    genotype_sds = 0.15
  ),
  simulation_params = list(max_events = 5),
  master_seed = 456
)
trajectory <- population_size(result)
trajectory_genetic <- population_size(result_genetic)
ylim_max <- max(trajectory$population_size, trajectory_genetic$population_size)
plot(trajectory, main = "No Genetic Variation", ylim = c(0, ylim_max))
plot(trajectory_genetic, main = "With Genetic Variation", ylim = c(0, ylim_max))
cat("Final size (no variation):", tail(trajectory$population_size, 1), "\n")
cat("Final size (with variation):", tail(trajectory_genetic$population_size, 1), "\n")
}
\seealso{
\code{\link{twolife_simulation}} for running simulations,
  \code{\link{snapshot_at_time}} for reconstructing population state at specific times
}
