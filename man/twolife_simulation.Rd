% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{twolife_simulation}
\alias{twolife_simulation}
\title{Run TWoLife Individual-Based Simulation}
\usage{
twolife_simulation(
  landscape_params = list(),
  individual_params = list(),
  genetic_params = list(),
  simulation_params = list(),
  history_detail = "standard",
  master_seed = NULL
)
}
\arguments{
\item{landscape_params}{List containing landscape parameters:
  \describe{
    \item{habitat}{Matrix (numeric). World Habitat Pixel Matrix. Binary (0/1) or continuous habitat values (0 to 1). Each pixel represents an environmental quality value at that location. Individuals experience fitness effects based on how well their phenotype matches the habitat value of their current location. Matrix dimensions define the landscape grid resolution. Required.}
    \item{cell_size}{Numeric. Length of the side of a landscape cell in world units. Defines the spatial resolution of the landscape. If habitat is a 100x100 matrix and cell_size = 1.0, the simulated world dimensions are 100x100 world units (world_width = 100, world_height = 100). All spatial parameters (step_length, neighbor_radius, coordinates) use these same world units. Individuals have continuous (x,y) coordinates and are not restricted to cell centers.}
    \item{boundary_condition}{Integer. Defines what happens to individuals attempting to move beyond world edges:
      \itemize{
        \item 1 = reflective: individuals attempting to move beyond the boundary bounce back into the landscape at the mirror position and remain in the simulation
        \item 2 = absorbing: individuals moving beyond the boundary permanently exit the simulation and are removed from the population, generating emigration events (recorded as event type = 3)
        \item 3 = periodic: individuals moving beyond one edge wrap to the opposite edge, creating torus topology (infinite landscape approximation)
      }
}
    \item{density_type}{Integer. Determines how population density is calculated for density-dependent demographic processes:
      \itemize{
        \item 1 = local: density calculated as number of individuals within neighbor_radius distance of the focal individual, divided by circular area. Represents spatially-explicit local competition (territoriality, local resource depletion).
        \item 2 = global: density calculated as total population size divided by total landscape area. Represents population-wide resource limitation.
      }
      
      Mathematical formulas:
      
      \deqn{\rho_{local} = \frac{N_{neighbors}}{\pi r^2}}
      
      \deqn{\rho_{global} = \frac{N_{total}}{W \times H}}
      
      Where:
      \itemize{
        \item \eqn{\rho} = density
        \item \eqn{N_{neighbors}} = number of neighbors within radius
        \item \eqn{N_{total}} = total population size
        \item \eqn{r} = neighbor_radius
        \item \eqn{W} = world_width, \eqn{H} = world_height
      }
      
      This density value is then used in birth and mortality rate calculations via birth_density_slope and mortality_density_slope parameters.}
    \item{matrix_mortality_multiplier}{Numeric. Mortality rate multiplier applied based on habitat suitability. Controls how mortality scales from optimal to unsuitable habitat. Values > 1 increase mortality in poor-quality habitat, creating "hostile matrix" effects.

      Mathematical application depends on whether individuals are perfect specialists or generalists:

      For perfect specialists (\eqn{\sigma = 0}):

      If individual is in exactly optimal habitat (habitat_value = environmental_optimum):

      \deqn{\mu = \mu_0 + \beta_\mu \rho}

      If individual is NOT in optimal habitat (matrix):

      \deqn{\mu = m \mu_0 + \beta_\mu \rho}

      For generalists (\eqn{\sigma > 0}):

      Mortality is interpolated based on habitat quality fitness:

      \deqn{\mu = \mu_{max} - f_{rel}(\mu_{max} - \mu_{min})}

      Where:
      \itemize{
        \item \eqn{\mu} = mortality rate
        \item \eqn{\mu_0} = base_mortality_rate
        \item \eqn{\beta_\mu} = mortality_density_slope
        \item \eqn{\rho} = density
        \item \eqn{m} = matrix_mortality_multiplier
        \item \eqn{\mu_{max} = m \mu_0} (maximum mortality)
        \item \eqn{\mu_{min} = \mu_0} (minimum mortality)
        \item \eqn{f_{rel}} = fitness_relative (ratio of fitness at current habitat to fitness at optimal habitat, ranges 0 to 1)
        \item \eqn{\sigma} = genotype_sds (niche width)
      }
      This creates a smooth gradient where mortality increases as habitat quality decreases, with the multiplier setting the maximum mortality in a completely unsuitable habitat.

}
    \item{matrix_dispersal_multiplier}{Numeric. Dispersal rate multiplier applied based on habitat suitability. Controls the frequency of dispersal events (not the distance per event) in unsuitable habitat. Values < 1 reduce dispersal frequency in matrix, while values > 1 increase it.

      Mathematical application (for perfect specialists with genotype_sds = 0):

      If individual is in exactly optimal habitat:

      \deqn{d = d_0}

      If individual is NOT in optimal habitat (matrix):

      \deqn{d = m_d d_0}

      Where:
      \itemize{
        \item \eqn{d} = dispersal_rate
        \item \eqn{d_0} = base_dispersal_rate
        \item \eqn{m_d} = matrix_dispersal_multiplier
      }

      For generalists (genotype_sds > 0), dispersal rate is not modified by habitat quality and remains at base_dispersal_rate.

      Important: This multiplier affects the rate (probability per time unit) of dispersal events occurring, NOT the distance moved per event. The step_length remains constant regardless of habitat quality. The dispersal rate is used in the Gillespie algorithm to determine when dispersal events occur.

}
  }}

\item{individual_params}{List containing individual-level parameters:
  \describe{
    \item{initial_population_size}{Integer. Number of individuals at simulation start.}
    \item{neighbor_radius}{Numeric. Distance (in world units) within which other individuals are counted as neighbors for local density calculations. Only used when density_type = 1 (local).

      Mathematical application:

      \deqn{\rho_{local} = \frac{N_{neighbors}}{\pi r^2}}

      Where \eqn{r} = neighbor_radius

}
    \item{vision_angle}{Numeric. Angular range (in radians) within which an individual can change direction during dispersal.

      Mathematical application:

      When performing random walk dispersal (sampling_points = 0), the individual's bearing is updated by adding a random angle uniformly sampled from [-vision_angle/2, vision_angle/2]:

      \deqn{\theta_{new} = \theta_{current} + U\left(-\frac{\alpha}{2}, \frac{\alpha}{2}\right)}

      Then movement occurs:

      \deqn{\Delta x = L \cos(\theta_{new})}

      \deqn{\Delta y = L \sin(\theta_{new})}

      Where:
      \itemize{
        \item \eqn{\theta} = bearing (direction in radians)
        \item \eqn{\alpha} = vision_angle
        \item \eqn{L} = step_length
        \item \eqn{U(a,b)} = uniform distribution from a to b
      }

}
    \item{step_length}{Numeric. Maximum distance (in world units) an individual moves during each dispersal event.

      Mathematical application:

      For random walk (sampling_points = 0), the individual moves exactly this distance in the chosen direction.

      For habitat selection (sampling_points > 0), candidate locations are sampled uniformly within a circle of radius step_length around the current position:

      \deqn{r \sim U(0, L)}

      \deqn{\theta \sim U(0, 2\pi)}

      Candidate location:

      \deqn{x_{candidate} = x_{current} + r \cos(\theta)}

      \deqn{y_{candidate} = y_{current} + r \sin(\theta)}

      Where:
      \itemize{
        \item \eqn{r} = distance from current position
        \item \eqn{\theta} = angle in radians
        \item \eqn{L} = step_length
      }

}
    \item{base_dispersal_rate}{Numeric. Baseline probability per time unit that a dispersal event occurs (range: 0-1). Modified by habitat quality for perfect specialists (genotype_sds = 0) via matrix_dispersal_multiplier.}
    \item{base_birth_rate}{Numeric. Baseline probability per time unit that a birth event occurs (range: 0-1).

      Mathematical application:

      For specialists (\eqn{\sigma = 0}) in optimal habitat:

      \deqn{b = b_0 - \beta_b \rho}

      For specialists in non-optimal habitat:

      \deqn{b = 0}

      For generalists (\eqn{\sigma > 0}):

      \deqn{b = \max(0, b_0 - \beta_b \rho)}

      Where:
      \itemize{
        \item \eqn{b} = birth_rate
        \item \eqn{b_0} = base_birth_rate
        \item \eqn{\beta_b} = birth_density_slope
        \item \eqn{\rho} = density
        \item \eqn{\sigma} = genotype_sds
      }

      Birth rate is set to 0 if the calculation yields a negative value.

}
    \item{base_mortality_rate}{Numeric. Baseline probability per time unit that a mortality event occurs (range: 0-1). Mathematical application shown in matrix_mortality_multiplier parameter.}
    \item{birth_density_slope}{Numeric. Controls the strength of negative density-dependence on birth rate. Higher values cause birth rate to decrease more rapidly as local density increases.

      Mathematical application:

      \deqn{b = b_0 - \beta_b \rho}

      Where \eqn{\beta_b} = birth_density_slope

}
    \item{mortality_density_slope}{Numeric. Controls the strength of positive density-dependence on mortality rate. Higher values cause mortality rate to increase more rapidly as local density increases.

      Mathematical application (for specialists in optimal habitat):

      \deqn{\mu = \mu_0 + \beta_\mu \rho}

      Where \eqn{\beta_\mu} = mortality_density_slope

}
    \item{initial_placement_mode}{Integer. Determines how individuals are positioned at simulation start:
      \itemize{
        \item 1 = random placement
        \item 2 = random placement anywhere with bivariate normal distribution centered on landscape center, with \eqn{\sigma_{placement} = L \sqrt{d_0}}
        \item 3 = custom coordinates (requires initial_x_coordinates and initial_y_coordinates)
      }
      
      Where \eqn{L} = step_length and \eqn{d_0} = base_dispersal_rate
}
    \item{initial_x_coordinates}{Numeric vector. Custom x-coordinates for initial individual positions. Required if initial_placement_mode = 3. Length must equal initial_population_size.}
    \item{initial_y_coordinates}{Numeric vector. Custom y-coordinates for initial individual positions. Required if initial_placement_mode = 3. Length must equal initial_population_size.}
  }}

\item{genetic_params}{List containing genetic parameters (each can be single value or vector matching initial_population_size):
  \describe{
    \item{genotype_means}{Numeric. The underlying genetic optimum value(s) for each individual. Represents the habitat value at which fitness is maximized. Should be on the same scale as habitat values.

      Mathematical application:

      Fitness is calculated using a Gaussian (normal) function:

      \deqn{f = \frac{1}{\sigma \sqrt{2\pi}} \exp\left(-\frac{(h - p)^2}{2\sigma^2}\right)}

      Where:
      \itemize{
        \item \eqn{f} = fitness (ranges 0 to 1)
        \item \eqn{h} = habitat_value at current location
        \item \eqn{p} = phenotype (derived from genotype_means, see plasticities parameter)
        \item \eqn{\sigma} = genotype_sds (niche width)
      }

      Can be:
      \itemize{
        \item Single value: all individuals start with the same genotype
        \item Vector: each individual starts with a different genotype
      }

}
    \item{genotype_sds}{Numeric. Standard deviation parameter of the Gaussian fitness function. Determines tolerance to habitat mismatch (niche width).

      Fitness function:

      \deqn{f = \frac{1}{\sigma \sqrt{2\pi}} \exp\left(-\frac{(h - p)^2}{2\sigma^2}\right)}

      Effect on fitness:
      \itemize{
        \item \eqn{\sigma = 0}: Perfect specialist. Fitness = 1 only when \eqn{h} exactly equals \eqn{p}, otherwise fitness = 0. Enables matrix_dispersal_multiplier effects.
        \item \eqn{\sigma > 0}: Generalist. Fitness decreases gradually as distance from optimal habitat increases. Larger values = broader tolerance.
      }

}
    \item{mutation_rates}{Numeric. Standard deviation of mutations added to offspring genotype at each birth event.

      Mathematical application:

      \deqn{g_{offspring} = g_{parent} + \varepsilon}

      Where \eqn{\varepsilon \sim N(0, \mu_r)} and \eqn{\mu_r} = mutation_rate

      Effect:
      \itemize{
        \item \eqn{\mu_r = 0}: No mutation, offspring genotype identical to parent
        \item \eqn{\mu_r > 0}: Offspring genotype varies from parent, enabling evolution
      }

}
    \item{plasticities}{Numeric. Standard deviation of the normal distribution from which phenotypic noise is drawn. Controls non-heritable phenotypic variation within an individual's lifetime.

      Mathematical application:

      At birth (once per individual, not changing during lifetime):

      \deqn{p = g + \varepsilon_p}

      Where:
      \itemize{
        \item \eqn{p} = phenotype (expressed trait)
        \item \eqn{g} = genotype (genetic trait)
        \item \eqn{\varepsilon_p \sim N(0, \psi)} = random environmental effect
        \item \eqn{\psi} = plasticity parameter
      }

      Difference from mutation:
      \itemize{
        \item Mutation: affects offspring genotype (heritable)
        \item Plasticity: affects individual phenotype (not heritable, determined once at birth)
      }

      The phenotype is then used in fitness calculations and habitat selection, while genotype is passed to offspring.

}
    \item{sampling_points}{Integer. Number of candidate locations sampled within step_length distance during each dispersal event when performing habitat selection.

      Mathematical application:

      When sampling_points = 0:
      \itemize{
        \item Individual performs simple random walk (vision_angle-constrained movement)
        \item No habitat selection occurs
      }

      When sampling_points > 0:
      \itemize{
        \item Individual samples sampling_points random locations within step_length radius
        \item Habitat quality evaluated at each candidate location
        \item Final location chosen via habitat selection using habitat_selection_temperature parameter
        \item Larger values = more informed habitat choice but slower computation
      }

      Only relevant when plasticities > 0 or when habitat selection is desired.}
    \item{habitat_selection_temperatures}{Numeric. Temperature parameter for the softmax function used in habitat selection. Controls the strength of preference for high-quality habitat during dispersal. Must be positive.

      Mathematical application:

      When choosing among candidate locations (sampling_points > 0), the probability of selecting location i is:

      \deqn{P(i) = \frac{\exp(f_i / T)}{\sum_{j=1}^{n} \exp(f_j / T)}}

      Where:
      \itemize{
        \item \eqn{P(i)} = probability of selecting location i
        \item \eqn{f_i} = fitness at location i (from Gaussian fitness function)
        \item \eqn{T} = habitat_selection_temperature
        \item \eqn{n} = sampling_points (number of candidate locations)
      }

      Effect of temperature values:
      \itemize{
        \item \eqn{T \to 0}: Strong selection, nearly deterministic choice of best habitat
        \item \eqn{T = 1}: Balanced selection, probability proportional to relative fitness
        \item \eqn{T \to \infty}: Weak selection, more random exploration
      }

}
  }}

\item{simulation_params}{List containing simulation control parameters:
  \describe{
    \item{max_events}{Integer. Maximum number of events to simulate before stopping.

      An "event" is any demographic or movement action: birth, death, dispersal, or emigration. The simulation uses a Gillespie algorithm where time advances stochastically between events.

      Time advancement between events:

      Delta t ~ Exponential(rate = sum(all individual rates))

      Where individual rates = dispersal_rate + birth_rate + death_rate for each individual.

      The simulation processes events sequentially until max_events is reached, population goes extinct, or population exceeds 1,000,000.

}
    \item{neutral_mode}{Logical. If TRUE, disables habitat selection and genetic variation to create a neutral null model.

      Effects when neutral_mode = TRUE:
      \itemize{
        \item All individuals assigned the mean genotype of the initial population
        \item Habitat selection disabled (all locations equally preferred)
        \item Useful for null model comparisons to isolate effects of habitat selection and evolution
      }

}
  }}

\item{history_detail}{Character. Level of detail recorded in event history. Higher detail levels enable more analyses but use more memory.

  Options:
  \itemize{
    \item "minimal": Records only time, event type, and individual ID. Fastest, smallest memory footprint. Sufficient for population size trajectories.
    \item "standard": Adds spatial coordinates (x, y), patch ID, and genotype for each event. Enables spatial and genetic analyses. Recommended for most uses.
    \item "full": Adds phenotype and niche width (genotype_sds) for each event. Enables complete historical reconstruction. Use when analyzing plasticity or detailed evolutionary dynamics.
  }}

\item{master_seed}{Integer. Random seed for reproducible simulations. If NULL, results are stochastic.}
}
\value{
A list of class 'twolife_result' with components:
  \describe{
    \item{summary}{List with status ("surviving" or "extinct"), final_population_size (integer),
      total_events (integer), and duration (numeric time units)}
    \item{survivors}{Data frame with columns: id (integer), x (numeric), y (numeric),
      genotype (numeric), phenotype (numeric), width (numeric). Empty data frame if extinct.}
    \item{spatial}{List containing world_width (numeric), world_height (numeric),
      world_size (numeric, maximum dimension: max(world_width, world_height)), num_patches (integer)}
    \item{events}{List with event history. Content depends on history_detail:
      \itemize{
        \item Always included: times (numeric vector), types (integer vector: -1=initial, 0=death,
          1=birth, 2=movement, 3=emigration), individual_ids (integer vector)
        \item If history_detail is "standard" or "full": patch_ids, x_coordinates, y_coordinates, genotypes
        \item If history_detail == "full": phenotypes, widths
      }}
    \item{parameters}{Nested list preserving all input parameters (landscape, individual, genetic, simulation)}
  }
}
\description{
Runs a spatially-explicit individual-based simulation with habitat selection,
genetic variation, phenotypic plasticity, and demographic processes. Supports
rectangular landscapes and customizable habitat selection parameters.
}
\details{
Simulation Algorithm:
  The simulation uses a Gillespie algorithm (stochastic simulation algorithm) where:
  \enumerate{
    \item Each individual has rates for three possible events: birth, death, and dispersal
    \item Time advances exponentially:
      \deqn{\Delta t \sim \text{Exp}(\lambda)}
      Where:
      \deqn{\lambda = \sum_{i=1}^{N} (d_i + b_i + \mu_i)}
      And for each individual i:
      \itemize{
        \item \eqn{d_i} = dispersal rate
        \item \eqn{b_i} = birth rate
        \item \eqn{\mu_i} = mortality rate
        \item \eqn{N} = current population size
      }
    \item One event occurs per time step, chosen proportionally to rates
    \item Individual rates update after density or location changes
  }

Stopping Conditions:
  The simulation stops when:
  \itemize{
    \item Population reaches 0 (extinction)
    \item Population exceeds 1,000,000 individuals (overflow protection)
    \item max_events is reached
  }
  User interruption via Ctrl+C or Esc is checked every 1000 events.

Event Types:
  Events are recorded with integer type codes:
  \itemize{
    \item -1: Initial placement (simulation start)
    \item 0: Death
    \item 1: Birth
    \item 2: Movement (dispersal within landscape)
    \item 3: Emigration (exit through absorbing boundary)
  }
}
\section{Default Values}{

When parameters are not specified, the following defaults are used:

\preformatted{
landscape_params = list(
  habitat = NULL,               # Required - must provide matrix
  cell_size = 1.0,
  boundary_condition = 1,
  density_type = 1,
  matrix_mortality_multiplier = 2.0,
  matrix_dispersal_multiplier = 0.5
)

individual_params = list(
  initial_population_size = 200,
  neighbor_radius = 2.0,
  vision_angle = pi,
  step_length = 1.0,
  base_dispersal_rate = 0.1,
  base_birth_rate = 0.3,
  base_mortality_rate = 0.20,
  birth_density_slope = 0.02,
  mortality_density_slope = 0.02,
  initial_placement_mode = 1,
  initial_x_coordinates = NULL,
  initial_y_coordinates = NULL
)

genetic_params = list(
  genotype_means = 1,
  genotype_sds = 0,
  mutation_rates = 0,
  plasticities = 0,
  sampling_points = 0,
  habitat_selection_temperatures = 1.0
)

simulation_params = list(
  max_events = 50 * initial_population_size,
  neutral_mode = FALSE
)

history_detail = "standard"
master_seed = NULL
}
}

\examples{
# Quick example for CRAN checks (< 2 seconds)
set.seed(100)
landscape <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  habitat_proportion = 0.6,
  return_as_landscape_params = TRUE
)

result <- twolife_simulation(
  landscape_params = landscape,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  simulation_params = list(max_events = 150),
  master_seed = 123
)

print(result)
head(result$survivors)

# With genetic variation
result_genetic <- twolife_simulation(
  landscape_params = landscape,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  genetic_params = list(
    genotype_means = rnorm(15, mean = 0.5, sd = 0.15),
    genotype_sds = 0.15
  ),
  simulation_params = list(max_events = 150),
  master_seed = 456
)

\donttest{
# Larger examples (not run during CRAN checks)
landscape_full <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.7,
  habitat_proportion = 0.4,
  return_as_landscape_params = TRUE
)

# Longer simulation for detailed analysis
result_long <- twolife_simulation(
  landscape_params = landscape_full,
  individual_params = list(initial_population_size = 10),
  simulation_params = list(max_events = 5000),
  history_detail = "full"
)

# Analyze population trajectory
pop_trajectory <- population_size(result_long)
plot(pop_trajectory$time, pop_trajectory$population_size, type = "l")
}

}
