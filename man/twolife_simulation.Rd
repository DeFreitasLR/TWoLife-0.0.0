% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{twolife_simulation}
\alias{twolife_simulation}
\title{Run TWoLife Individual-Based Simulation}
\usage{
twolife_simulation(
  landscape_params = list(),
  individual_params = list(),
  genetic_params = list(),
  simulation_params = list(),
  history_detail = "standard",
  master_seed = NULL
)
}
\arguments{
\item{landscape_params}{List containing landscape parameters:
\describe{
  \item{habitat}{Matrix (integer, logical or numeric). World Habitat Pixel Matrix. Matriz values should be binary (0/1, T/F) or continuous habitat values (from 0 to 1). Each value represents represents an environmental quality value of a pixel. Individuals experience fitness effects based on how well their phenotype matches the habitat value of the pixel they are located.  Matrix dimensions define the landscape size and grid resolution. Required.}
  \item{cell_size}{Numeric. Length of the side of a landscape cell in world units. Defines the spatial resolution of the landscape. If habitat is a 100x100 matrix and cell_size = 1.0, the simulated world dimensions are 100x100 world units (world_width = 100, world_height = 100). All spatial parameters (step_length, neighbor_radius, coordinates) use these same world units. The position of individuals have are in continuous (x,y) coordinates and are not restricted to pixel centers.}
  \item{boundary_condition}{Integer. Defines what happens to individuals that reach the edges of world borders:
    \itemize{
      \item 1 = reflective: agent keeps its speed, but its path "bounces" off the border at the same angle it hit it (angle of incidence equals angle of reflection);
      \item 2 = absorbing: individuals that cross borders permanently exit the simulation and are removed from the population, generating emigration events (recorded as event type = 3)
      \item 3 = periodic: individuals moving beyond one edge wrap to the opposite edge, creating torus topology (infinite landscape approximation)
    }}
  \item{density_type}{Integer. Determines how population density is calculated for density-dependent demographic processes to be applied to each individual:
    \itemize{
      \item 1 = local: density calculated as number of individuals within a neighbor_radius distance of the focal individual. Represents local, spatially-explicit local competition (territoriality, local resource depletion).
      \item 2 = global: density calculated as total population size divided by total landscape area. Represents population-wide resource limitation.
    }
    
    This density value is then used in birth and mortality rate calculations via birth_density_slope and mortality_density_slope parameters. See Details for mathematical formulas.}
  \item{matrix_mortality_multiplier}{Numeric. Mortality rate multiplier applied based on habitat suitability. Controls how mortality scales from optimal to unsuitable habitat. Values > 1 increase mortality in poor-quality habitat, creating "hostile matrix" effects. For perfect specialists (genotype_sds = 0), the multiplier is applied directly in non-optimal habitat. For generalists (genotype_sds > 0), mortality is interpolated based on fitness, creating a smooth gradient. See Details for mathematical formulas.}
  \item{matrix_dispersal_multiplier}{Numeric. Dispersal rate multiplier applied based on habitat suitability. Controls the frequency of dispersal events (not the distance per event) in unsuitable habitat. Values < 1 reduce dispersal frequency in matrix, while values > 1 increase it. For perfect specialists (genotype_sds = 0), the multiplier is applied in non-optimal habitat. For generalists (genotype_sds > 0), dispersal rate remains at base_dispersal_rate regardless of habitat. Important: This affects the rate of dispersal events, NOT the distance (step_length). See Details for mathematical formulas.}
}}

\item{individual_params}{List containing individual-level parameters:
  \describe{
    \item{initial_population_size}{Integer. Number of individuals at simulation start.}
    \item{neighbor_radius}{Numeric. Distance (in world units) within which other individuals are counted as neighbors for local density calculations. Only used when density_type = 1 (local). See Details section 'Density Calculations' for formula.}
    \item{vision_angle}{Numeric. Angular range (in radians) within which an individual can change direction during random walk dispersal (sampling_points = 0). See Details section 'Habitat Selection' for movement formulas.}
    \item{step_length}{Numeric. Maximum distance (in world units) an individual moves during each dispersal event. For random walk (sampling_points = 0), individual moves exactly this distance in chosen direction. For habitat selection (sampling_points > 0), defines the radius for sampling candidate locations. See Details section 'Habitat Selection' for formulas.}
    \item{base_dispersal_rate}{Numeric. Baseline probability per time unit that a dispersal event occurs (range: 0-1). Modified by habitat quality for perfect specialists (genotype_sds = 0) via matrix_dispersal_multiplier.}
    \item{base_birth_rate}{Numeric. Baseline probability per time unit that a birth event occurs (range: 0-1). Modified by density-dependence (see birth_density_slope) and by habitat quality for perfect specialists (specialists cannot reproduce in non-optimal habitat). See Details section 'Birth Rate Calculations' for formulas.}
    \item{base_mortality_rate}{Numeric. Baseline probability per time unit that a mortality event occurs (range: 0-1). Mathematical application shown in matrix_mortality_multiplier parameter.}
    \item{birth_density_slope}{Numeric. Controls the strength of negative density-dependence on birth rate. Higher values cause birth rate to decrease more rapidly as local density increases. See Details section 'Birth Rate Calculations' for formula.}
    \item{mortality_density_slope}{Numeric. Controls the strength of positive density-dependence on mortality rate. Higher values cause mortality rate to increase more rapidly as local density increases. See Details sections 'Matrix Mortality Multiplier' and 'Density Calculations' for formulas.}
    \item{initial_placement_mode}{Integer. Determines how individuals are positioned at simulation start:
      \itemize{
        \item 1 = uniform random placement 
        \item 2 = random placement following bivariate normal distribution centered on landscape center, with \eqn{\sigma_{placement} = L \sqrt{d_0}}
        \item 3 = custom coordinates (requires initial_x_coordinates and initial_y_coordinates)
      }
      
      Where \eqn{L} = step_length and \eqn{d_0} = base_dispersal_rate
}
    \item{initial_x_coordinates}{Numeric vector. Custom x-coordinates for initial individual positions. Required if initial_placement_mode = 3. Length must equal initial_population_size.}
    \item{initial_y_coordinates}{Numeric vector. Custom y-coordinates for initial individual positions. Required if initial_placement_mode = 3. Length must equal initial_population_size.}
  }}

\item{genetic_params}{List containing genetic parameters. Each parameter can be either a single value (applied to all individuals) or a vector with length equal to initial_population_size (one value per individual). If a vector is provided with length different from initial_population_size, an error is raised. R's automatic vector recycling is not used to avoid unintended parameter assignments:
\describe{
  \item{genotype_means}{Numeric. The genetic environmental optimum value(s) for each individual. Represents the habitat value at which fitness is maximized for each genotype. Should be on the same scale as habitat values (e.g., 0-1). Can be single value (all individuals same genotype) or vector (different genotypes per individual). See Details section 'Fitness Function' for how genotype determines fitness.}
  \item{genotype_sds}{Numeric. Niche width parameter controlling tolerance to habitat mismatch. When = 0, individual is perfect specialist (fitness = 1 only at exact optimum, enables matrix_dispersal_multiplier effects). When > 0, individual is generalist (fitness decreases gradually with habitat deviation, larger values = broader tolerance). See Details section 'Fitness Function' for mathematical formula.}
  \item{mutation_rates}{Numeric. Standard deviation of mutations added to offspring genotype at each birth event. When = 0, offspring genotype identical to parent. When > 0, offspring genotype varies from parent enabling genetic evolution. Mutations are heritable (passed to future generations). See Details section 'Genetic Mechanisms' for formula.}
  \item{plasticities}{Numeric. Controls non-heritable phenotypic variation. Standard deviation of phenotypic noise added to genotype at birth (once per individual, fixed for lifetime). When = 0, phenotype equals genotype. When > 0, phenotype varies around genotype. Phenotype (not genotype) determines fitness and habitat selection. Plasticity is NOT heritable (unlike mutation). See Details section 'Genetic Mechanisms' for formula and comparison with mutation.}
  \item{sampling_points}{Integer. Number of candidate locations sampled within step_length distance during each dispersal event. When sampling_points = 0, individuals perform vision_angle-constrained random walk. When sampling_points > 0, individuals perform habitat selection by sampling candidate locations and choosing the best according to the habitat_selection_temperatures parameter. Larger values enable more informed habitat choice but slower computation. See Details for mathematical formulas.}
  \item{habitat_selection_temperatures}{Positive real. Temperature parameter for softmax function in habitat selection (sampling_points > 0). Controls strength of preference for high-quality habitat. Lower values → stronger selection for best habitat (nearly deterministic). Higher values → more random exploration. T = 1 gives balanced selection proportional to relative fitness. See Details section 'Habitat Selection' for mathematical formula.}
}}

\item{simulation_params}{List containing simulation control parameters:
\describe{
  \item{max_events}{Integer. Maximum number of events to simulate before stopping. An "event" is any demographic or movement action: birth, death, dispersal, or emigration. The simulation processes events sequentially until max_events is reached, population goes extinct, or population exceeds 1,000,000. See Details for information on the Gillespie algorithm and time advancement.}
  \item{neutral_mode}{Logical. If TRUE, creates a null model without genetic variation or habitat selection. Effects: (1) all individuals are assigned the mean genotype of the initial population with no variation, (2) habitat selection is disabled (individuals perform random walk regardless of sampling_points), and (3) no fitness-based selection occurs (all habitats are equivalent). Demographic processes (birth, death, dispersal rates) and movement mechanics remain unchanged. Useful for null model comparisons to isolate effects of genetic variation and habitat selection.}
}}

\item{history_detail}{Character. Level of detail recorded in event history outputed by the function. Higher detail levels enable more analyses but use more memory.

  Options:
  \itemize{
    \item minimal: Records only time, event type, and individual ID. Fastest, smallest memory footprint. Sufficient for population size trajectories.
    \item standard: Adds spatial coordinates (x, y), pixel ID (the landscape grid cell where the individual is located), and genotype for each event. Enables spatial and genetic analyses. Recommended for most uses.
    \item full: Adds phenotype and niche width for each event. The niche width is the phenotypic standard deviation (genotype_sds) of each individual at each moment, representing the breadth of habitats where the individual maintains high fitness. Enables complete historical reconstruction. Use when analyzing plasticity or detailed evolutionary dynamics.
  }}

\item{master_seed}{Integer. Random seed for reproducible simulations. If NULL, results are stochastic.}
}
\value{
A list of class 'twolife_result' with components:
  \describe{
    \item{summary}{List with status (surviving or extinct), final_population_size (integer),
      total_events (integer), and duration (numeric time units)}
    \item{survivors}{Data frame with columns: id (integer), x (numeric), y (numeric),
      genotype (numeric), phenotype (numeric), width (numeric). Empty data frame if extinct.}
    \item{spatial}{List containing world_width (numeric), world_height (numeric),
      world_size (numeric, maximum dimension: max(world_width, world_height)), num_patches (integer)}
    \item{events}{List with event history. Content depends on history_detail:
      \itemize{
        \item Always included: times (numeric vector), types (integer vector: -1=initial, 0=death,
          1=birth, 2=movement, 3=emigration), individual_ids (integer vector)
        \item If history_detail is "standard" or "full": patch_ids, x_coordinates, y_coordinates, genotypes
        \item If history_detail == "full": phenotypes, widths
      }}
    \item{parameters}{Nested list preserving all input parameters (landscape, individual, genetic, simulation)}
  }
}
\description{
Runs a spatially-explicit individual-based simulation with habitat selection,
genetic variation, phenotypic plasticity, and demographic processes. Supports
rectangular landscapes and customizable habitat selection parameters.
}
\details{
Simulation Algorithm:
  The simulation uses a Gillespie algorithm (stochastic simulation algorithm) where:
  \enumerate{
    \item Each individual has rates for three possible events: birth, death, and dispersal
    \item Time advances exponentially:
      \deqn{\Delta t \sim \text{Exp}(\lambda)}
      Where:
      \deqn{\lambda = \sum_{i=1}^{N} (d_i + b_i + \mu_i)}
      And for each individual i:
      \itemize{
        \item \eqn{d_i} = dispersal rate
        \item \eqn{b_i} = birth rate
        \item \eqn{\mu_i} = mortality rate
        \item \eqn{N} = current population size
      }
    \item One event occurs per time step, chosen proportionally to rates
    \item Individual rates update after density or location changes
  }

Stopping Conditions:
  The simulation stops when:
  \itemize{
    \item Population reaches 0 (extinction)
    \item Population exceeds 1,000,000 individuals (overflow protection)
    \item max_events is reached
  }
  User interruption via Ctrl+C or Esc is checked every 1000 events.

Event Types:
  Events are recorded with integer type codes:
  \itemize{
    \item -1: Initial placement (simulation start)
    \item 0: Death
    \item 1: Birth
    \item 2: Movement (dispersal within landscape)
    \item 3: Emigration (exit through absorbing boundary)
  }

Density Calculations:
  Population density is calculated differently depending on density_type:
  
  For local density (density_type = 1):
  \deqn{\rho_{local} = \frac{N_{neighbors}}{\pi r^2}}
  
  For global density (density_type = 2):
  \deqn{\rho_{global} = \frac{N_{total}}{W \times H}}
  
  Where:
  \itemize{
    \item \eqn{\rho} = density
    \item \eqn{N_{neighbors}} = number of neighbors within radius
    \item \eqn{N_{total}} = total population size
    \item \eqn{r} = neighbor_radius
    \item \eqn{W} = world_width, \eqn{H} = world_height
  }

Matrix Mortality Multiplier:
  The matrix_mortality_multiplier controls how mortality scales with habitat quality:
  
  For perfect specialists (genotype_sds = 0):
  \itemize{
    \item In optimal habitat: \eqn{\mu = \mu_0 + \beta_\mu \rho}
    \item In non-optimal habitat: \eqn{\mu = m \mu_0 + \beta_\mu \rho}
  }
  
  For generalists (genotype_sds > 0):
  \deqn{\mu = \mu_{max} - f_{rel}(\mu_{max} - \mu_{min})}
  
  Where:
  \itemize{
    \item \eqn{\mu} = mortality rate
    \item \eqn{\mu_0} = base_mortality_rate
    \item \eqn{\beta_\mu} = mortality_density_slope
    \item \eqn{\rho} = density
    \item \eqn{m} = matrix_mortality_multiplier
    \item \eqn{\mu_{max} = m \mu_0} (maximum mortality in worst habitat)
    \item \eqn{\mu_{min} = \mu_0} (minimum mortality in optimal habitat)
    \item \eqn{f_{rel}} = relative fitness (0 to 1)
  }

Matrix Dispersal Multiplier:
  The matrix_dispersal_multiplier controls the frequency of dispersal events:
  
  For perfect specialists (genotype_sds = 0):
  \itemize{
    \item In optimal habitat: \eqn{d = d_0}
    \item In non-optimal habitat: \eqn{d = m_d d_0}
  }
  
  For generalists (genotype_sds > 0), dispersal rate remains \eqn{d_0} regardless of habitat.
  
  Where:
  \itemize{
    \item \eqn{d} = dispersal_rate
    \item \eqn{d_0} = base_dispersal_rate
    \item \eqn{m_d} = matrix_dispersal_multiplier
  }

Habitat Selection:
  When sampling_points > 0, individuals perform habitat selection:
  \enumerate{
    \item Sample n = sampling_points candidate locations uniformly within step_length radius:
      \deqn{r \sim U(0, L), \quad \theta \sim U(0, 2\pi)}
      \deqn{x_{candidate} = x_{current} + r \cos(\theta)}
      \deqn{y_{candidate} = y_{current} + r \sin(\theta)}
    \item Calculate fitness at each candidate location
    \item Choose location probabilistically using softmax with temperature parameter:
      \deqn{P(location_i) = \frac{\exp(f_i / T)}{\sum_{j=1}^{n} \exp(f_j / T)}}
  }
  
  When sampling_points = 0, individuals perform random walk:
  \deqn{\theta_{new} = \theta_{current} + U\left(-\frac{\alpha}{2}, \frac{\alpha}{2}\right)}
  \deqn{\Delta x = L \cos(\theta_{new}), \quad \Delta y = L \sin(\theta_{new})}
  
  Where:
  \itemize{
    \item \eqn{L} = step_length
    \item \eqn{\alpha} = vision_angle
    \item \eqn{T} = habitat_selection_temperatures
    \item \eqn{f_i} = fitness at location i
  }

Birth Rate Calculations:
  Birth rates vary with density and habitat quality:
  
  For perfect specialists (genotype_sds = 0):
  \itemize{
    \item In optimal habitat: \eqn{b = b_0 - \beta_b \rho}
    \item In non-optimal habitat: \eqn{b = 0} (cannot reproduce)
  }
  
  For generalists (genotype_sds > 0):
  \deqn{b = \max(0, b_0 - \beta_b \rho)}
  
  Where:
  \itemize{
    \item \eqn{b} = birth_rate
    \item \eqn{b_0} = base_birth_rate
    \item \eqn{\beta_b} = birth_density_slope
    \item \eqn{\rho} = density (from density_type calculation)
  }
  
  Birth rate is constrained to non-negative values. Specialists have strong habitat-dependent reproduction, while generalists can reproduce (at reduced rates) across habitat gradients.

Fitness Function:
  Individual fitness determines survival, reproduction, and habitat selection success. Fitness is calculated using a Gaussian function:
  
  \deqn{f = \exp\left(-\frac{(h - p)^2}{2\sigma^2}\right)}
  
  Where:
  \itemize{
    \item \eqn{f} = fitness (ranges 0 to 1)
    \item \eqn{h} = habitat value at current location
    \item \eqn{p} = phenotype (individual's expressed environmental optimum)
    \item \eqn{\sigma} = genotype_sds (niche width parameter)
  }
  
  Specialist vs Generalist Behavior:
  \itemize{
    \item \eqn{\sigma = 0} (Perfect Specialist): 
      \itemize{
        \item Fitness = 1 when \eqn{h = p} (exact match)
        \item Fitness = 0 otherwise (any mismatch)
        \item Enables matrix_dispersal_multiplier and strict habitat-dependent reproduction
        \item Strong selection pressure for matching habitat
      }
    \item \eqn{\sigma > 0} (Generalist):
      \itemize{
        \item Fitness = 1 when \eqn{h = p} (optimal habitat)
        \item Fitness decreases gradually as \eqn{|h - p|} increases
        \item Larger \eqn{\sigma} = broader tolerance (flatter fitness curve)
        \item Can survive and reproduce across habitat gradients
      }
  }
  
  Fitness affects multiple processes:
  \itemize{
    \item Mortality rates (via matrix_mortality_multiplier for generalists)
    \item Birth rates (specialists cannot reproduce in non-optimal habitat)
    \item Habitat selection (via habitat_selection_temperatures during dispersal)
  }

Genetic Mechanisms:
  TWoLife implements two sources of variation:
  
  Mutation (Heritable Genetic Variation):
  \deqn{g_{offspring} = g_{parent} + \varepsilon_{mutation}}
  
  Where \eqn{\varepsilon_{mutation} \sim N(0, \mu_r)} and \eqn{\mu_r} = mutation_rate
  
  \itemize{
    \item Occurs at birth event
    \item Modifies offspring's genotype
    \item Passed to future generations (HERITABLE)
    \item Enables evolutionary adaptation
    \item When \eqn{\mu_r = 0}, offspring genotype = parent genotype exactly
  }
  
  Plasticity (Non-heritable Phenotypic Variation):
  \deqn{p = g + \varepsilon_{plasticity}}
  
  Where \eqn{\varepsilon_{plasticity} \sim N(0, \psi)} and \eqn{\psi} = plasticity parameter
  
  \itemize{
    \item Occurs once at birth, fixed for individual's lifetime
    \item Determines phenotype from genotype
    \item NOT passed to offspring (offspring get parent's genotype, not phenotype)
    \item Represents environmental/developmental noise
    \item When \eqn{\psi = 0}, phenotype = genotype exactly
  }
  
  Key Distinction:
  \itemize{
    \item Genotype: Inherited genetic value (evolves via mutation)
    \item Phenotype: Expressed trait value (genotype + plastic noise)
    \item Fitness calculation uses phenotype
    \item Inheritance passes genotype
    \item Both mutation and plasticity add variation, but only mutation is evolutionary
  }
}
\section{Default Values}{

When parameters are not specified, the following defaults are used:

\preformatted{
landscape_params = list(
  habitat = NULL,               # Required - must provide matrix
  cell_size = 1.0,
  boundary_condition = 1,
  density_type = 1,
  matrix_mortality_multiplier = 2.0,
  matrix_dispersal_multiplier = 0.5
)

individual_params = list(
  initial_population_size = 200,
  neighbor_radius = 2.0,
  vision_angle = pi,
  step_length = 1.0,
  base_dispersal_rate = 0.1,
  base_birth_rate = 0.3,
  base_mortality_rate = 0.20,
  birth_density_slope = 0.02,
  mortality_density_slope = 0.02,
  initial_placement_mode = 1,
  initial_x_coordinates = NULL,
  initial_y_coordinates = NULL
)

genetic_params = list(
  genotype_means = 1,
  genotype_sds = 0,
  mutation_rates = 0,
  plasticities = 0,
  sampling_points = 0,
  habitat_selection_temperatures = 1.0
)

simulation_params = list(
  max_events = 50 * initial_population_size,
  neutral_mode = FALSE
)

history_detail = "standard"
master_seed = NULL
}
}

\examples{
# Quick example for CRAN checks (< 2 seconds)
set.seed(100)
landscape <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.5,
  habitat_proportion = 0.6,
  return_as_landscape_params = TRUE
)

result <- twolife_simulation(
  landscape_params = landscape,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  simulation_params = list(max_events = 150),
  master_seed = 123
)

print(result)
head(result$survivors)

# With genetic variation
result_genetic <- twolife_simulation(
  landscape_params = landscape,
  individual_params = list(
    initial_population_size = 15,
    base_birth_rate = 0.4,
    base_mortality_rate = 0.15
  ),
  genetic_params = list(
    genotype_means = rnorm(15, mean = 0.5, sd = 0.15),
    genotype_sds = 0.15
  ),
  simulation_params = list(max_events = 150),
  master_seed = 456
)

\donttest{
# Larger examples (not run during CRAN checks)
landscape_full <- create_fractal_landscape(
  cells_per_row = 5,
  fractality = 0.7,
  habitat_proportion = 0.4,
  return_as_landscape_params = TRUE
)

# Longer simulation for detailed analysis
result_long <- twolife_simulation(
  landscape_params = landscape_full,
  individual_params = list(initial_population_size = 10),
  simulation_params = list(max_events = 5000),
  history_detail = "full"
)

# Analyze population trajectory
pop_trajectory <- population_size(result_long)
plot(pop_trajectory$time, pop_trajectory$population_size, type = "l")
}

}
