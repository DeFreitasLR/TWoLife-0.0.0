---
title: "TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes"
author: "Lucas Freitas"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
bibliography: references.bib
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  cache = FALSE
)
```

# Introduction

Understanding population dynamics in spatially heterogeneous environments—where environmental conditions vary across space—requires modeling both landscape structure (the spatial arrangement of environmental conditions) and individual variation (differences among individuals in traits affecting fitness) [@Turner1989; @Bolnick2011]. Existing approaches typically simplify one or both dimensions: agent-based models (computational simulations tracking individual organisms) often assume discrete habitat types (categorical suitable/unsuitable classifications) [@Grimm2005], while analytical models (mathematical equations) treat individuals as identical units [@Levins1969; @Hanski1999]. **TWoLife** integrates these dimensions by simulating populations as collections of genetically variable individuals inhabiting spatially complex landscapes.

The package enables researchers to:

1.  Generate landscapes with **continuous environmental gradients** (smoothly varying conditions across space) or **discrete habitat patches** (distinct areas of suitable vs. unsuitable habitat)
2.  Model **individual genetic variation** in optimal environmental values (conditions where fitness is maximized), tolerance ranges (breadth of survivable conditions), and behavioral strategies (e.g., habitat selection decisions)
3.  Implement **evolutionary and adaptive mechanisms** including mutation (random genetic changes transmitted to offspring), phenotypic plasticity (within-generation adjustment to environmental conditions), and natural selection (differential survival based on trait-environment matching)
4.  Track **phenotype-environment interactions** (how well individual traits match local conditions) that determine fitness and spatial distribution
5.  Analyze **emergent population dynamics** (population-level patterns arising from individual decisions and fates) from individual-level processes (birth, death, dispersal, and trait evolution)

This vignette demonstrates TWoLife's capabilities through two complementary analyses. We begin with a simplified example showing basic workflow and discrete habitat structure, then proceed to the main analysis showcasing individual genetic variation in continuous environmental gradients—the core innovation of TWoLife.

# Package Setup

Before using TWoLife functions, we load the package and set a seed for reproducibility:

```{r load-package}
library(TWoLife)

# Set seed for reproducible results across all subsequent operations
set.seed(42)
```

# Package Overview

## Main Function

TWoLife simulations are executed through a single main function that accepts five components: three parameter lists controlling different aspects of the simulation, plus master seed for reproducibility. The function structure is:

```{r eval=FALSE}
twolife_simulation(
  landscape_params,     # List: spatial environment configuration
  individual_params,    # List: population initialization settings
  genetic_params,       # List: individual variation (optional)
  simulation_params,    # List: simulation control and stopping conditions
  master_seed           # Integer: ensures complete reproducibility
)
```

Each parameter list is a standard R list containing named elements. The `landscape_params` list must include a habitat matrix. The `individual_params` list specifies initial population size and optional starting configurations. The `genetic_params` list is optional—when omitted, individuals use default genetic values (all identical with genotype=0.5, no tolerance, no evolution). The `simulation_params` list controls simulation duration through `max_events` or `max_time`. The `master_seed` ensures all random processes (initialization, demographic events, mutations) produce identical results when re-run.

## Key Concepts

**Landscapes**

Spatial environments are represented as numeric matrices where each cell contains an environmental value. TWoLife supports two landscape types that differ fundamentally in how environmental variation is represented:

- **Continuous landscapes**: Environmental values vary smoothly across space along gradients. Values typically range from 0.0 to 1.0, representing continuous variation in conditions such as temperature (e.g., 0°C to 30°C rescaled to 0-1), moisture (e.g., 0% to 100% soil moisture), or resource availability. In continuous landscapes, fitness depends on the match between individual phenotypes and local environmental values through Gaussian matching. No locations are inherently "unsuitable"—suitability emerges from the interaction between individual traits and local conditions.

- **Discrete landscapes**: Space is divided into binary categories where each cell is classified as either suitable habitat (value=1) or unsuitable matrix (value=0). This representation is common in fragmented landscapes where habitat patches are embedded in a surrounding matrix that cannot support populations. In discrete landscapes, individuals can only survive in habitat cells (value=1), and matrix cells (value=0) are immediately lethal.

Landscapes are generated using `create_fractal_landscape()`, which produces realistic spatial patterns with self-similar structure across spatial scales. The fractal algorithm ensures that pattern complexity (patchiness vs. smoothness) is similar whether the landscape is viewed at fine resolution (individual cells) or coarse resolution (blocks of cells), mimicking natural spatial processes.

**Individuals**

Each individual in TWoLife is a simulated organism (computational agent) with heritable genetic traits. Unlike models where fitness is pre-assigned by location type, fitness in TWoLife emerges dynamically from phenotype-environment matching: how well an individual's expressed traits align with local environmental conditions determines survival probability.

Individuals are characterized by five genetic attributes that together determine ecological and evolutionary outcomes:

-   **`genotype_mean`** (Optimal environmental value): The environmental condition at which the individual achieves maximum fitness (survival probability = 1.0). This represents the genetically-determined optimal niche position. Values typically range from 0 to 1, matching the landscape's environmental scale. For example, an individual with genotype_mean=0.3 is genetically adapted to environmental value 0.3 (e.g., cool temperatures if the gradient represents temperature). When an individual occupies a location with environmental value exactly matching its genotype_mean (adjusted by plasticity), fitness equals 1.0.

-   **`genotype_sd`** (Niche width/tolerance): The breadth of environmental conditions the individual can tolerate, represented mathematically as the standard deviation (σ) in the Gaussian fitness function. This parameter controls how steeply fitness declines as environmental conditions deviate from the optimum. Smaller values (e.g., genotype_sd=0.05) indicate specialists with narrow tolerance ranges who perform well only near their optimal value—fitness drops rapidly with small environmental mismatches. Larger values (e.g., genotype_sd=0.3) indicate generalists with broad tolerance who maintain high fitness across a wide range of conditions—fitness declines gradually even with substantial environmental mismatches. A genotype_sd of 0.15 means approximately 95% of fitness is retained within ±0.3 units of the optimal value (±2σ).

-   **`plasticity`** (Phenotypic plasticity rate): The rate at which an individual's expressed phenotype can shift toward local environmental values within its lifetime. This parameter controls within-generation acclimation capacity. Values range from 0 to 1:
    - plasticity=0: No plasticity—the expressed phenotype permanently equals genotype_mean regardless of local environment. The individual cannot adjust.
    - plasticity=0.3: Moderate plasticity—each time step, the phenotype shifts 30% of the distance from its current value toward the local environmental value. This represents partial, gradual acclimation.
    - plasticity=1.0: Complete plasticity—the phenotype immediately adjusts to perfectly match the local environmental value (within tolerance limits set by genotype_sd). This represents instantaneous, perfect acclimation.
    
    Plasticity represents reversible acclimation or behavioral thermoregulation, not genetic change. If an individual with plasticity=0.5, genotype_mean=0.4, and current phenotype=0.4 moves to a location with environment=0.6, its phenotype shifts to 0.4 + 0.5×(0.6-0.4) = 0.5. Plasticity enables individuals to improve fitness in sub-optimal conditions but cannot exceed the limits set by tolerance (genotype_sd).

-   **`mutation_rate`**: The probability that offspring inherit a genotype_mean different from the parent value. When mutation occurs (tested at each birth event), offspring genotype_mean is drawn from a normal distribution centered on the parent's genotype_mean with standard deviation determined by the mutation rate. Typical values range from 0 (no evolution) to 0.1 (10% chance per reproduction). For example, with mutation_rate=0.05, each offspring has a 5% chance of receiving a mutated genotype_mean drawn from Normal(parent_genotype_mean, σ_mutation). This parameter enables evolutionary adaptation across generations as beneficial mutations (those increasing fitness in current conditions) accumulate and spread through the population via natural selection.

-   **`sampling_points`** (Habitat selection intensity): The number of potential dispersal locations an individual evaluates before deciding where to move. This parameter controls habitat selection behavior:
    - sampling_points=1: Random dispersal with no habitat selection. The individual moves to a randomly chosen location without evaluation, representing passive dispersal (e.g., wind-dispersed seeds).
    - sampling_points=10: Moderate selectivity. The individual evaluates 10 random locations and selects among them using a softmax function weighted by expected fitness at each location, representing limited assessment capacity.
    - sampling_points=100: High selectivity. The individual evaluates 100 locations, enabling sophisticated habitat selection that approaches optimal placement, representing organisms with strong habitat assessment abilities (e.g., birds evaluating multiple territories).
    
    Higher sampling_points values allow individuals to locate more suitable microhabitats, but at computational cost. The softmax selection process means individuals prefer high-fitness locations but retain some randomness, preventing unrealistic determinism.

All five attributes are heritable with modification (subject to mutation), enabling evolutionary dynamics and potential local adaptation over multiple generations. For example, if populations persist in heterogeneous landscapes, natural selection may favor individuals with broader tolerance (larger genotype_sd) or higher plasticity.

**Fitness**

Survival probability is determined by Gaussian matching—a mathematical function that quantifies the match between an individual's phenotype and local environmental conditions:

$$\text{fitness} = \exp\left(-\frac{(\text{phenotype} - \text{environment})^2}{2 \times \text{tolerance}^2}\right)$$

where:
- **phenotype** is the individual's expressed trait value, which equals genotype_mean initially but can shift through plasticity toward local environmental values
- **environment** is the environmental value at the cell where the individual currently resides (ranges from 0 to 1 in continuous landscapes, or 0/1 in binary landscapes)
- **tolerance** is the individual's genotype_sd (niche width parameter)

This Gaussian function produces a bell-shaped fitness curve centered on the phenotype. When phenotype perfectly matches the local environment, the numerator equals zero and fitness equals 1.0 (maximum survival probability). As the mismatch increases, fitness declines exponentially. The tolerance parameter controls the rate of decline:

- **Narrow tolerance** (small genotype_sd, e.g., 0.05): Fitness drops rapidly with small mismatches. An individual with genotype_sd=0.05 has fitness ≈0.6 when mismatch is 0.05, and fitness ≈0.14 when mismatch is 0.1. These specialists require close matches to survive.

- **Broad tolerance** (large genotype_sd, e.g., 0.3): Fitness declines gradually even with substantial mismatches. An individual with genotype_sd=0.3 maintains fitness ≈0.95 when mismatch is 0.05, and fitness ≈0.61 when mismatch is 0.1. These generalists survive across wide environmental ranges.

This fitness framework differs fundamentally from models with pre-assigned habitat quality, where fitness depends only on location type (e.g., habitat=suitable, matrix=unsuitable). In TWoLife, fitness emerges dynamically from trait-environment interactions, allowing investigation of adaptive matching, local adaptation, and niche evolution without assuming fitness landscapes a priori.

## Simulation Output

Simulations return a list object containing four components that provide different levels of detail about population outcomes:

-   **`summary`**: A list of final population statistics including `final_population_size` (number surviving at simulation end), `total_births` (cumulative birth events), `total_deaths` (cumulative death events), `total_dispersals` (cumulative dispersal events), and `final_time` (simulation duration). This component provides a quick overview of population outcomes.

-   **`survivors`**: A data frame where each row represents one surviving individual at simulation end. Columns include `individual_id`, `genotype` (genotype_mean value), `genotype_sd`, `phenotype` (current expressed value), `x` and `y` (spatial coordinates), `habitat_quality` (local environmental value), and `fitness` (current survival probability). This component enables analysis of trait distributions, spatial patterns, and phenotype-environment matching among survivors.

-   **`events`**: A data frame recording every demographic event that occurred during the simulation. Each row documents one event with columns: `time` (when event occurred), `event_type` ("birth", "death", or "dispersal"), `individual_id`, `parent_id` (for births), `x` and `y` (location), and relevant trait values. This complete history enables analysis of population dynamics, demographic rates over time, and lineage tracking.

-   **`parameters`**: A list storing all input parameters (landscape_params, individual_params, genetic_params, simulation_params, master_seed). This ensures complete reproducibility—simulations can be exactly replicated by re-running with stored parameters. It also enables systematic comparison across parameter combinations.

## Basic Workflow

A typical TWoLife analysis follows five steps:

1.  **Create landscape**: Use `create_fractal_landscape()` to generate spatial environments with desired properties (continuous vs. discrete, spatial autocorrelation level, habitat proportion)
2.  **Configure parameters**: Prepare the three parameter lists (landscape_params, individual_params, genetic_params) specifying landscape, initial population, and genetic attributes
3.  **Run simulation**: Execute `twolife_simulation()` with parameters and master_seed
4.  **Extract results**: Access components of the output list directly (e.g., `sim$summary$final_population_size`) or use helper functions like `population_size()` to extract time series
5.  **Visualize**: Use built-in plotting functions (`plot_landscape()`, `check_habitat_match()`) or create custom visualizations from survivors and events data

This workflow enables rapid iteration through parameter combinations, facilitating both exploratory analysis and systematic hypothesis testing.

# Basic Workflow Demonstration

Before exploring TWoLife's core capabilities (individual variation in continuous landscapes), we demonstrate basic workflow using a simpler scenario: discrete habitat/matrix landscapes—where suitable habitat patches are embedded in an unsuitable matrix (the unsuitable areas between patches). This introductory example shows the main function structure, parameter organization, and output format using the classic SLOSS (Single Large or Several Small) conservation debate: whether a single large habitat reserve better supports populations than several small reserves with the same total area [@Diamond1975].

## Creating Landscapes

TWoLife provides `create_fractal_landscape()` for generating spatial patterns with realistic spatial structure. The fractal algorithm creates landscapes where pattern complexity is self-similar across spatial scales—patchiness looks similar whether viewing individual cells or large regions. This mimics natural processes like topography or vegetation patterns.

The function accepts four key parameters for binary (discrete) landscapes:

- `cells_per_row`: Landscape resolution (e.g., 15 produces a 15×15 grid = 225 total cells)
- `fractality`: Controls spatial autocorrelation (the degree to which nearby cells have similar values). Values near 0 produce high local variation with patchy patterns, while values near 1 produce smooth, homogeneous landscapes. We use 0.5 for intermediate spatial structure.
- `habitat_proportion`: For binary landscapes, this specifies the fraction of cells classified as suitable habitat (value=1). The remaining fraction becomes matrix (value=0). Setting this to 1.0 creates 100% habitat (pristine landscape), while 0.2 creates 20% habitat embedded in 80% matrix.
- `min_value` and `max_value`: Not used for binary landscapes (always 0 and 1), but important for continuous landscapes (discussed later).

We create three landscape configurations to test the SLOSS question:

```{r sloss-landscapes}
# Pristine landscape: 100% suitable habitat, no fragmentation
set.seed(100)
pristine_landscape <- create_fractal_landscape(
  cells_per_row = 15,      # 15×15 = 225 total cells
  fractality = 0.5,        # Intermediate spatial structure  
  habitat_proportion = 1.0 # 100% habitat (no matrix)
)

# Pre-configured SLOSS landscapes from package data
# Both have identical habitat area (20%) but different spatial configurations
single_large_patch <- single_large      # 20% coverage concentrated in 1 large patch
several_small_patches <- several_small  # 20% coverage distributed across multiple small patches
```

The figure below visualizes these three landscape configurations. Dark green indicates suitable habitat (value=1), while white indicates unsuitable matrix (value=0). All three configurations will be initialized with 100 individuals to test how spatial arrangement affects population outcomes:

```{r visualize-sloss, fig.width=9, fig.height=3, echo=FALSE}
par(mfrow = c(1, 3), mar = c(4, 4, 3, 2))
plot_landscape(pristine_landscape, 
                            main = "Pristine\n(100% habitat)", 
                            colors = "habitat")
plot_landscape(single_large_patch, 
                            main = "Single Large\n(20% habitat)", 
                            colors = "habitat")
plot_landscape(several_small_patches, 
                            main = "Several Small\n(20% habitat)", 
                            colors = "habitat")
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Running Simulations

The core `twolife_simulation()` function requires three parameter lists plus a master seed. Each list is a standard R list containing named elements that control different simulation aspects:

**landscape_params**: A list containing the habitat matrix and optional environmental values. For this basic example, we provide only the habitat component—a matrix where 1=suitable habitat and 0=unsuitable matrix. The function interprets this binary matrix as a discrete landscape where individuals can only survive in habitat cells.

**individual_params**: A list controlling initial population configuration. The `initial_population_size` element specifies how many individuals to place at simulation start (here, 100). Additional optional elements include `initial_positions` (custom starting locations; default is random placement in habitat cells) and `initial_ages` (age distribution; default is all age 0).

**genetic_params**: A list specifying individual trait values. When omitted (as in this basic example), all individuals use default values: genotype_mean=0.5, genotype_sd=0.1, mutation_rate=0, plasticity=0, sampling_points=1. These defaults create a genetically uniform population with moderate tolerance, no evolution, and random dispersal—appropriate for testing landscape effects without genetic complications.

**simulation_params**: A list controlling simulation duration and stopping conditions. The `max_events` element specifies how many demographic events (births, deaths, dispersals combined) to execute before stopping. Here we use 300 events, sufficient to observe population dynamics without excessive computation. Alternatively, `max_time` could specify simulation duration in time units.

**master_seed**: An integer ensuring reproducibility. All random processes (initial placement, birth/death/dispersal events, mutations, habitat selection) use this seed, guaranteeing identical results when the simulation is re-run with the same seed. Different seeds produce different random realizations while keeping all mechanisms identical.

We run three simulations, one per landscape configuration, using identical population and simulation parameters. Only the landscape differs, isolating its effect:

```{r sloss-simulations}
sim_pristine <- twolife_simulation(
  landscape_params = list(habitat = pristine_landscape),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 42
)

sim_single_large <- twolife_simulation(
  landscape_params = list(habitat = single_large_patch),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 43  # Different seed for independent realization
)

sim_several_small <- twolife_simulation(
  landscape_params = list(habitat = several_small_patches),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 44  # Different seed for independent realization
)
```

Note that we use different master seeds (42, 43, 44) for the three simulations. This ensures independent random realizations—each simulation experiences different sequences of demographic events. Using identical seeds would make comparisons less meaningful because differences could arise from particular random events rather than landscape structure.

## Extracting Results

Simulation objects are lists containing multiple components (summary, survivors, events, parameters). The `summary` component provides aggregated statistics about final population outcomes. We extract final population sizes to compare configurations:

```{r sloss-results}
# Extract final population sizes from summary component
final_pops <- c(
  Pristine = sim_pristine$summary$final_population_size,
  Single_Large = sim_single_large$summary$final_population_size,
  Several_Small = sim_several_small$summary$final_population_size
)
final_pops

# Population trajectories using helper function
# population_size() extracts time series from events component
trajectory_pristine <- population_size(sim_pristine)
head(trajectory_pristine, 3)
```

The `population_size()` helper function processes the events component to compute population size at each time point. It returns a data frame with `time` and `population_size` columns, enabling visualization of population dynamics over simulation duration.

The figure below compares final population sizes (left panel) and population dynamics over time (right panel) across the three landscape configurations. The left panel shows that reducing habitat from 100% (pristine) to 20% causes substantial population decline. The right panel reveals temporal dynamics: populations may grow initially, decline due to deaths exceeding births, or fluctuate around equilibrium depending on landscape carrying capacity:

```{r sloss-comparison, fig.width=8, fig.height=4, echo=FALSE}
par(mfrow = c(1, 2), mar = c(4, 4, 3, 2))

# Barplot of final population sizes
barplot(final_pops, 
        main = "Final Population Sizes",
        ylab = "Population Size (N)",
        col = c("darkgreen", "blue", "red"),
        las = 1)
text(x = seq(0.7, by = 1.2, length.out = 3), 
     y = final_pops + max(final_pops) * 0.05,
     labels = final_pops, cex = 1.1, font = 2)

# Population trajectories over time
trajectory_single <- population_size(sim_single_large)
trajectory_several <- population_size(sim_several_small)

plot(trajectory_pristine$time, trajectory_pristine$population_size, 
     type = "l", col = "darkgreen", lwd = 2,
     main = "Population Dynamics", 
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max(trajectory_pristine$population_size) * 1.05))
lines(trajectory_single$time, trajectory_single$population_size, 
      col = "blue", lwd = 2)
lines(trajectory_several$time, trajectory_several$population_size, 
      col = "red", lwd = 2)
legend("topright", legend = names(final_pops), 
       col = c("darkgreen", "blue", "red"), lwd = 2, bty = "n")

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Summary

The pristine landscape supports `r final_pops["Pristine"]` individuals at simulation end. Reducing habitat to 20% yields `r final_pops["Single_Large"]` individuals (single large configuration) versus `r final_pops["Several_Small"]` individuals (several small configuration). `r if(final_pops["Several_Small"] == 0) "The fragmented configuration experienced complete collapse, demonstrating that spatial arrangement can determine viability beyond simple area calculations. Fragmentation into multiple small patches may prevent population persistence even when total habitat area is identical." else paste0("The spatial configuration accounts for a ", abs(final_pops["Single_Large"] - final_pops["Several_Small"]), "-individual difference despite identical total habitat area (both 20%), illustrating how spatial arrangement affects population outcomes independently of habitat amount.")`

This example demonstrates TWoLife's basic workflow: landscape creation, parameter configuration, simulation execution, and result extraction. The discrete landscape example introduced the function structure and basic operations. We now turn to the package's primary innovation: modeling individual genetic variation in continuous environmental gradients, where fitness emerges from trait-environment matching rather than binary habitat classification.

------------------------------------------------------------------------

# Main Analysis: Individual Variation in Heterogeneous Environments

## Background and Motivation

Real environments exhibit continuous variation—temperature gradients from mountain bases to peaks, moisture clines from wet to dry regions, resource density surfaces shaped by topography and soil [@Turner1989; @Wiens1976]. Real populations contain genetically variable individuals with different optimal conditions and tolerance ranges, as documented extensively in natural systems [@Bolnick2003; @Lynch1998]. Traditional models simplify these dimensions: discrete habitat models cannot represent gradual environmental transitions, while models assuming genetic uniformity cannot investigate how diversity affects population outcomes.

TWoLife explicitly models both dimensions—continuous environmental gradients and individual genetic variation—enabling investigation of questions that are challenging for traditional approaches:

-   **How much genetic variation is necessary** for persistence in heterogeneous landscapes? Can populations survive with genetic diversity in optimal values alone, or do other traits matter more?
-   **Is diversity in optimal values sufficient**, or must individuals also possess tolerance ranges (niche width) enabling survival across environmental conditions? Does

 tolerance trump diversity?
-   **What roles do evolution and behavior play** relative to standing genetic variation already present in populations? Do these mechanisms provide substantial additional benefits, or are their effects marginal?
-   **How do mechanisms interact**—additively (each adds independent benefit) or synergistically (combined effects exceed simple addition)? Understanding interaction patterns helps predict which mechanisms are most critical.

We address these questions through progressive addition of genetic and behavioral mechanisms across five scenarios. Each scenario differs only in genetic parameters while holding all other conditions constant (landscape, initial population size, simulation duration, master seeds), allowing us to isolate each mechanism's contribution to population outcomes.

## Generating Continuous Landscapes

Setting `habitat_proportion = NULL` instructs `create_fractal_landscape()` to generate continuous environmental values rather than binary habitat/matrix classification. The function produces values ranging from `min_value` to `max_value` (here, 0.0 to 1.0) with spatial structure controlled by `fractality`.

The `fractality` parameter controls spatial autocorrelation—the statistical degree to which nearby locations have similar values. This determines landscape patchiness:

- **fractality near 0** (e.g., 0.1): High local variation with low autocorrelation. Adjacent cells often have very different values, creating a fine-grained, highly heterogeneous mosaic. This represents environments with high small-scale variation (e.g., rocky outcrops with scattered vegetation).

- **fractality near 1** (e.g., 0.9): Low local variation with high autocorrelation. Adjacent cells have very similar values, creating large homogeneous regions with smooth gradients. This represents environments with broad-scale patterns (e.g., elevation gradients with gradually changing temperatures).

- **fractality = 0.5**: Intermediate spatial structure with balanced autocorrelation. Creates realistic landscapes with moderate patchiness—regions of similar values cluster together but sharp transitions also occur. This intermediate value is appropriate for many natural systems.

We generate a continuous landscape for our main analysis:

```{r continuous-landscape}
set.seed(200)
continuous_landscape <- create_fractal_landscape(
  cells_per_row = 15,
  fractality = 0.5,              # Balanced spatial autocorrelation
  habitat_proportion = NULL,      # NULL = continuous values (not binary 0/1)
  min_value = 0.0,               # Minimum environmental value
  max_value = 1.0                # Maximum environmental value
)
```

The resulting landscape contains 225 cells (15×15) with environmental values ranging continuously from 0.0 to 1.0. These values represent environmental conditions (temperature, moisture, resource availability, or any relevant gradient) but carry no inherent "quality"—a value of 0.3 is not intrinsically better or worse than 0.7. Fitness depends on phenotype-environment matching: an individual with genotype_mean=0.3 performs best at 0.3, while an individual with genotype_mean=0.7 performs best at 0.7.

```{r visualize-continuous, fig.width=5, fig.height=4.5, echo=FALSE}
plot_landscape(continuous_landscape, 
                            main = "Continuous Environmental Landscape\n(fractality = 0.5)", 
                            colors = "terrain")
```

The visualization uses a terrain color scheme where cooler colors (blues, greens) represent low environmental values and warmer colors (yellows, reds) represent high values. Observe the intermediate-scale patchiness created by fractality=0.5—some clustering of similar values occurs, but substantial variation exists across the landscape.

This phenotype-environment matching framework distinguishes TWoLife from models that pre-assign habitat quality based solely on location type. Here, fitness emerges dynamically from the interaction between individual traits and local conditions, allowing investigation of adaptive matching, local adaptation trajectories, and niche evolution without assuming fitness landscapes a priori.

## Experimental Design: Progressive Mechanisms

We implement five scenarios that differ only in genetic parameters, with all other conditions held constant. This factorial design allows us to isolate each mechanism's contribution to population outcomes:

| Scenario | Genetic Diversity | Niche Width | Evolution | Behavior | Configuration |
|----------|------------------|-------------|-----------|----------|---------------|
| 1. Uniform specialists | No (all genotype=1.0) | No (sds=0) | No | No | Default parameters |
| 2. Variable specialists | Yes (genotypes 0.3-0.7) | No (sds=0) | No | No | genotype_means only |
| 3. Generalists | Yes | **Yes (sds=0.15)** | No | No | Add genotype_sds |
| 4. Evolution | Yes | Yes | **Yes** (mutation + plasticity) | No | Add mutation, plasticity |
| 5. Habitat selection | Yes | Yes | Yes | **Yes** (sampling=100) | Add sampling_points |

All scenarios use identical conditions except genetic parameters:
- Same landscape (continuous_landscape generated above)
- Same initial population size (40 individuals)
- Same simulation duration (250 demographic events)
- Different but comparable master seeds (45-49)

The progressive design means each scenario builds on the previous one by adding a single mechanism. This allows us to attribute population changes to specific mechanisms and test whether mechanisms interact additively or synergistically.

Before running scenarios, we pre-generate genotype_mean values for Scenarios 2-5 to ensure comparability. Using the same genotype distribution across scenarios isolates the effects of tolerance, evolution, and behavior without confounding by different starting genetic compositions:

```{r pre-generate-genotypes}
# Pre-generate genotypes for Scenarios 2-5
# Uniform distribution from 0.3 to 0.7 captures environmental range
set.seed(300)
initial_genotypes <- runif(40, 0.3, 0.7)
```

## Scenario 1: Uniform Perfect Specialists

**Configuration:** All individuals genetically identical (genotype_mean=1.0, the default value) with zero tolerance (genotype_sd=0, also default). This represents a population of perfect specialists requiring exact environmental match for survival. Since default parameters apply when genetic_params is omitted, we simply exclude that argument.

**Hypothesis:** The population will rapidly collapse because the landscape lacks environmental values of exactly 1.0, and zero tolerance means individuals cannot survive any environmental mismatch, however slight. Even if a cell has value 0.999, individuals with genotype 1.0 and tolerance 0 will die because the Gaussian fitness function yields near-zero fitness for any mismatch when tolerance approaches zero.

**Rationale:** This extreme scenario establishes a baseline showing that genetic uniformity combined with perfect specialization is incompatible with environmental heterogeneity in continuous landscapes. It demonstrates the necessity of either genetic diversity or tolerance for persistence.

```{r scenario1}
sim_s1 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  # Omit genetic_params to use defaults: all genotype=1.0, sd=0
  simulation_params = list(max_events = 250),
  master_seed = 45
)

(pop_s1 <- sim_s1$summary$final_population_size)
```

**Result:** N = `r pop_s1` (extinct, as hypothesized). The landscape's environmental values range from `r sprintf("%.2f", min(continuous_landscape))` to `r sprintf("%.2f", max(continuous_landscape))` with mean `r sprintf("%.2f", mean(continuous_landscape))`. No cells contain the value 1.0 required by the genetically uniform population. Even the maximum value (`r sprintf("%.2f", max(continuous_landscape))`) fails to support individuals with genotype=1.0 and tolerance=0, because the fitness function yields exp(-(1.0-max)²/(2×0²)) which approaches 0 for any mismatch.

**Interpretation:** This demonstrates that genetic uniformity combined with perfect specialization is incompatible with environmental heterogeneity in continuous landscapes. In nature, such populations would face extinction unless environments were unrealistically homogeneous. The result establishes that some form of physiological flexibility—either genetic diversity in optimal values or tolerance enabling survival across conditions—is necessary for persistence in heterogeneous environments.

## Scenario 2: Variable Specialists

**Configuration:** Different genotype_mean values uniformly distributed from 0.3 to 0.7 (capturing most of the landscape's environmental range), but tolerance remains zero (genotype_sd=0). This represents genetic diversity in optimal values without physiological flexibility—40 different genotypes but all are perfect specialists.

**Hypothesis:** Despite substantial genetic diversity spanning much of the environmental range, the population will still collapse. The issue is that continuous landscapes rarely provide exact matches to specific genotype values. The probability of a cell having value exactly 0.4573 (for instance) is essentially zero in continuous space. Without tolerance, individuals require exact matches that do not exist.

**Rationale:** This scenario tests whether genetic diversity alone suffices for persistence, or whether tolerance (niche width) is also necessary. Many classical population genetic models assume individuals differ in optimal values but do not explicitly model tolerance ranges. This scenario tests that assumption's adequacy for spatially heterogeneous environments.

```{r scenario2}
sim_s2 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes  # 40 different optimum values 0.3-0.7
    # genotype_sds defaults to 0 when not specified
  ),
  simulation_params = list(max_events = 250),
  master_seed = 46
)

(pop_s2 <- sim_s2$summary$final_population_size)
```

**Result:** N = `r pop_s2` (extinct, confirming hypothesis). Even with 40 different genotypes distributed across the environmental range (0.3-0.7), the probability of exact phenotype-environment matches remains negligible in continuous space. Each individual requires a cell with environmental value precisely matching its genotype_mean. While the landscape contains values throughout the 0-1 range, the probability that any specific cell has value exactly 0.4573, 0.5128, etc. (the 40 genotype values) is effectively zero.

**Interpretation:** Genetic diversity in optimal values alone is insufficient for persistence in continuous heterogeneous landscapes. Individuals also need tolerance ranges (niche width) enabling survival across a spectrum of conditions near their optimum. This result has important implications for conservation: maintaining genetic diversity may be necessary but is not sufficient—populations also need physiological flexibility to cope with environmental variation. The finding challenges models that represent individual variation solely through optimal values without explicit tolerance parameters.

## Scenario 3: Generalists (Niche Width)

**Configuration:** Same genotype diversity as Scenario 2 (genotype_means from 0.3-0.7), but now add genotype_sd=0.15 for all individuals. This creates tolerance ranges of approximately ±2σ = ±0.30 around each optimal value, converting narrow specialists into generalists capable of surviving across a range of conditions.

**Hypothesis:** Niche width will enable persistence by allowing individuals to survive across a spectrum of conditions rather than requiring exact matches. An individual with genotype_mean=0.5 and genotype_sd=0.15 can now survive reasonably well from approximately 0.2 to 0.8 (within ±2σ), dramatically expanding the portion of landscape that is effectively habitable.

**Rationale:** This scenario tests whether tolerance (niche width) is the critical mechanism enabling persistence in heterogeneous landscapes. The hypothesis predicts that tolerance is both necessary (Scenarios 1-2 failed without it) and sufficient (this scenario should succeed with it alone, without requiring evolution or behavior). If confirmed, this would establish tolerance as the fundamental determinant of persistence, with other mechanisms providing secondary enhancements.

```{r scenario3}
sim_s3 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,      # Same genetic diversity as S2
    genotype_sds = rep(0.15, 40)            # Add tolerance: key difference from S2
  ),
  simulation_params = list(max_events = 250),
  master_seed = 47
)

(pop_s3 <- sim_s3$summary$final_population_size)
```

**Result:** N = `r pop_s3` (`r sprintf("%.1f%%", pop_s3/40*100)` survival). This marks the **critical transition** from extinction (Scenarios 1-2: N=0) to viability (Scenario 3: N>0). The addition of tolerance alone, without evolution or behavior, enables population persistence.

We can examine survivor trait distributions to verify that tolerance enables persistence by expanding effective habitat:

```{r scenario3-analysis}
# Examine survivor trait distribution
if (pop_s3 > 0) {
  survivor_summary <- c(
    Mean_genotype = mean(sim_s3$survivors$genotype),
    SD_genotype = sd(sim_s3$survivors$genotype),
    Range = paste0("[", sprintf("%.2f", min(sim_s3$survivors$genotype)), 
                   ", ", sprintf("%.2f", max(sim_s3$survivors$genotype)), "]")
  )
  survivor_summary
}
```

The survivor genotype distribution shows which optimal values were favored by selection. If survivors span most of the initial genotype range (0.3-0.7), this indicates that diverse optimal values can persist when coupled with tolerance. Narrow survivor distributions would suggest strong environmental filtering even with tolerance.

**Mechanism explanation:** An individual with genotype_mean=0.5 and genotype_sd=0.15 achieves fitness using the Gaussian formula: fitness = exp(-(phenotype-environment)²/(2×0.15²)). When this individual occupies a cell with environment=0.5, fitness=1.0 (perfect match). At environment=0.3 or 0.7 (±0.2 units away), fitness remains ≈0.45—reduced but sufficient for survival. At environment=0.2 or 0.8 (±0.3 units), fitness ≈0.14—marginal but possible. This tolerance range transforms previously unusable portions of the landscape into accessible habitat. Previously, only exact matches (probability ≈0) enabled survival; now, a continuous range of conditions (±0.3 units ≈ 60% of landscape range) supports reasonable fitness.

**Interpretation:** Niche width (tolerance) is the key mechanism enabling persistence in heterogeneous environments. This single parameter—genotype_sd—determines the breadth of conditions an individual can survive, directly controlling how much of a heterogeneous landscape is effectively habitable. The transition from S2 (extinct) to S3 (viable) demonstrates that tolerance is both necessary (required for any persistence) and sufficient (enables persistence without additional mechanisms). This finding has important ecological implications: tolerance may be more critical than genetic diversity in optimal values for population persistence in variable environments.

## Scenario 4: Evolution (Mutation + Plasticity)

**Configuration:** Same as Scenario 3 (genotype diversity + tolerance), but add evolutionary mechanisms: mutation_rate=0.05 (5% probability of genetic change per reproduction event) and plasticity=0.02 (phenotypes can shift 2% per timestep toward local environmental values). These parameters enable both across-generation evolution (via mutation and selection) and within-generation acclimation (via plasticity).

**Hypothesis:** Evolutionary mechanisms will enhance persistence through dual-timescale adaptation. Plasticity provides rapid within-generation adjustment to local conditions, improving fitness immediately upon dispersal to new environments. Mutation enables gradual across-generation evolution as beneficial genotypes (those matching common environmental conditions) increase in frequency through natural selection. The combined effect should increase population size relative to Scenario 3.

**Rationale:** This scenario tests whether evolution provides substantial additional benefit beyond standing genetic variation and tolerance. If the population increase is large, evolution is important. If the increase is small or absent, standing variation and tolerance alone may suffice. The dual-timescale mechanisms (plasticity for immediate adjustment, mutation for long-term evolution) are biologically realistic and commonly invoked in adaptation theory.

```{r scenario4}
sim_s4 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),   # Enable evolution across generations
    plasticities = rep(0.02, 40)      # Enable plasticity within generations
  ),
  simulation_params = list(max_events = 250),
  master_seed = 48
)

(pop_s4 <- sim_s4$summary$final_population_size)
(delta_evolution <- pop_s4 - pop_s3)
```

**Result:** N = `r pop_s4` (change: `r sprintf("%+d", delta_evolution)` individuals from Scenario 3). Evolution `r if(delta_evolution > 0) paste0("enhanced survival by ", delta_evolution, " individuals, representing a ", sprintf("%.1f%%", delta_evolution/pop_s3*100), " increase over tolerance alone") else if(delta_evolution == 0) "maintained equivalent survival to tolerance alone, suggesting that standing variation and tolerance suffice for this landscape" else paste0("resulted in ", abs(delta_evolution), " fewer survivors than tolerance alone, likely due to demographic stochasticity rather than mechanism effects—this could represent chance variation given the short simulation duration")`.

**Mechanism explanation—Plasticity:** When an individual with plasticity=0.02 and genotype_mean=0.4 moves to a location with environment=0.6, its phenotype (initially equal to genotype_mean=0.4) begins shifting toward 0.6 at rate 0.02 per timestep. After one timestep: phenotype = 0.4 + 0.02×(0.6-0.4) = 0.404. After 10 timesteps: phenotype ≈ 0.438 (shifted 38% of the distance). This gradual adjustment improves fitness in sub-optimal locations without requiring genetic change, providing within-generation acclimation.

**Mechanism explanation—Mutation:** When an individual with mutation_rate=0.05 reproduces, offspring have 5% probability of receiving a mutated genotype_mean rather than exact parental value. If mutation occurs, offspring genotype_mean is drawn from a distribution centered on the parent value. Over multiple generations, beneficial mutations (those improving fitness given landscape conditions) increase in frequency through differential reproduction, causing gradual evolution of population mean genotype_mean toward prevalent environmental conditions.

**Interpretation:** Evolution and plasticity `r if(delta_evolution > 0) "provide measurable additional benefit beyond standing tolerance, though the effect is modest relative to tolerance's dramatic enabling effect (S2→S3 transition). These mechanisms enhance but cannot replace fundamental tolerance" else "appear to have limited additional effect beyond standing tolerance in this short simulation, suggesting tolerance is the dominant mechanism. Longer simulations might reveal greater evolutionary effects"`. The key insight is that evolution operates on top of—but cannot compensate for lack of—basic physiological flexibility (tolerance). Populations need tolerance first, then evolution can optimize trait distributions. This hierarchical importance has implications for conservation: protecting tolerant genotypes may be more critical than preserving evolvability.

## Scenario 5: Habitat Selection (Behavioral Optimization)

**Configuration:** Same as Scenario 4 (diversity + tolerance + evolution), but add sampling_points=100. Individuals now evaluate 100 potential dispersal locations before deciding where to move, selecting using softmax weighting by expected fitness at each location. This represents active habitat selection rather than random dispersal.

**Hypothesis:** Behavioral habitat selection will optimize spatial distribution and amplify the benefits of genetic variation by enabling individuals to actively seek conditions matching their phenotypes. Individuals with genotype_mean=0.3 should preferentially settle in low-value regions, while those with genotype_mean=0.7 should seek high-value regions. This active sorting should improve average fitness and increase population size relative to Scenario 4's random dispersal.

**Rationale:** This scenario tests whether behavior provides substantial additional benefit beyond genetics, tolerance, and evolution. Habitat selection is widespread in nature and has been hypothesized to facilitate local adaptation by ensuring individuals occupy suitable environments. If the population increase is substantial, behavior is an important mechanism deserving explicit modeling. If the increase is modest, passive processes (dispersal, selection on tolerance) may suffice.

```{r scenario5}
sim_s5 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),
    plasticities = rep(0.02, 40),
    sampling_points = rep(100, 40)  # Enable habitat selection
  ),
  simulation_params = list(max_events = 250),
  master_seed = 49
)

(pop_s5 <- sim_s5$summary$final_population_size)
(delta_behavior <- pop_s5 - pop_s4)
(cumulative_gain <- pop_s5 - pop_s2)
```

**Result:** N = `r pop_s5` (change: `r sprintf("%+d", delta_behavior)` individuals from Scenario 4). Cumulative improvement from the extinct baseline (Scenario 2, variable specialists without tolerance): **`r cumulative_gain` individuals gained** through sequential addition of tolerance (S2→S3), evolution (S3→S4), and behavior (S4→S5).

**Mechanism explanation:** With sampling_points=100, each dispersal event involves evaluating 100 randomly chosen locations. For each location j, expected fitness F_j is calculated using the individual's phenotype and that location's environmental value. The individual selects among locations using softmax probability: P_j = exp(F_j/τ) / Σ_k exp(F_k/τ), where τ is a temperature parameter controlling selection strength. This means individuals strongly prefer high-fitness locations but retain some probability of choosing sub-optimal sites, preventing unrealistic determinism. The result is that individuals with genotype_mean=0.3 tend to accumulate in low-value regions (better matches), while those with genotype_mean=0.7 accumulate in high-value regions.

**Interpretation:** Habitat selection provides `r if(delta_behavior > 0) paste0("additional enhancement (", delta_behavior, " individuals, ", sprintf("%.1f%%", delta_behavior/pop_s4*100), " increase) by enabling active spatial sorting. However, like evolution, behavior operates on top of—rather than replacing—fundamental tolerance") else "limited additional benefit in this scenario, suggesting that tolerance and evolution may be more important than active habitat selection, at least over short timescales"`. The cumulative gain analysis reveals the relative importance of mechanisms: tolerance (S2→S3) accounts for `r pop_s3-pop_s2` individuals (the transition from extinction to viability), while evolution and behavior together add `r pop_s5-pop_s3` individuals—substantial but secondary to tolerance's enabling effect.

## Comparative Analysis

The table below summarizes population outcomes across all five scenarios. The "Change" column shows each mechanism's incremental contribution, revealing relative importance:

```{r comparative-summary}
# Summary table showing progressive mechanism effects
results_summary <- data.frame(
  Scenario = c("S1: Uniform", "S2: Diversity", "S3: Tolerance", 
               "S4: Evolution", "S5: Behavior"),
  Final_N = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
  Change = c("—", 
             sprintf("%+d", pop_s2 - pop_s1),
             sprintf("%+d", pop_s3 - pop_s2),
             sprintf("%+d", pop_s4 - pop_s3),
             sprintf("%+d", pop_s5 - pop_s4)),
  Mechanism_Added = c("None (baseline)", 
                      "Genetic diversity in optima",
                      "Tolerance (niche width)",
                      "Mutation + plasticity",
                      "Habitat selection")
)
results_summary
```

The S2→S3 transition (adding tolerance) accounts for `r pop_s3 - pop_s2` individuals—the largest and most critical contribution representing the fundamental shift from extinction to viability. This single parameter change (adding genotype_sd=0.15) enables population persistence. Subsequent mechanisms provide incremental effects: evolution adds `r pop_s4 - pop_s3` individuals (`r sprintf("%.1f%%", (pop_s4-pop_s3)/pop_s3*100)` increase over tolerance alone), and behavior adds `r pop_s5 - pop_s4` individuals (`r sprintf("%.1f%%", (pop_s5-pop_s4)/pop_s4*100)` further increase).

The figure below shows population trajectories over time (left panel) and final population sizes (right panel) across scenarios. Note that Scenarios 1-2 (red bars, extinct) differ fundamentally from Scenarios 3-5 (yellow-green gradient, viable). The trajectory panel reveals temporal dynamics: S3 shows initial decline then stabilization, while S4-S5 show enhanced dynamics from evolutionary and behavioral mechanisms:

```{r comparative-visualization, fig.width=9, fig.height=4.5, echo=FALSE}
par(mfrow = c(1, 2), mar = c(5, 4, 3, 2))

# Extract population trajectories for viable scenarios
traj_s3 <- population_size(sim_s3)
traj_s4 <- population_size(sim_s4)
traj_s5 <- population_size(sim_s5)

# Population dynamics over time (only viable scenarios shown)
max_pop <- max(c(traj_s3$population_size, traj_s4$population_size, traj_s5$population_size))
plot(traj_s3$time, traj_s3$population_size, type = "l", col = "blue", lwd = 2,
     main = "Population Trajectories\n(Viable Scenarios Only)", 
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max_pop * 1.05))
lines(traj_s4$time, traj_s4$population_size, col = "darkgreen", lwd = 2)
lines(traj_s5$time, traj_s5$population_size, col = "purple", lwd = 2)
abline(h = 40, lty = 2, col = "gray50", lwd = 1)
text(max(traj_s3$time)*0.02, 42, "Initial N=40", pos = 4, cex = 0.8, col = "gray50")
legend("topright", legend = c("S3: Tolerance", "S4: Evolution", "S5: Behavior"),
       col = c("blue", "darkgreen", "purple"), lwd = 2, bty = "n", cex = 0.85)

# Final population sizes (all scenarios)
barplot(c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
        names.arg = c("S1", "S2", "S3", "S4", "S5"),
        main = "Final Population Sizes\n(All Scenarios)",
        ylab = "Population Size (N)",
        col = c("red", "red", "yellow", "lightgreen", "darkgreen"),
        las = 1)
text(x = seq(0.7, by = 1.2, length.out = 5), 
     y = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5) + max(c(1, pop_s3, pop_s4, pop_s5)) * 0.05,
     labels = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
     cex = 1.1, font = 2)
abline(h = 0, lwd = 0.5)

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Verifying Phenotype-Environment Matching

The `check_habitat_match()` function provides diagnostic visualization to verify that survivors occupy environmentally suitable locations. Each panel shows: (left) the landscape with survivor positions colored by their phenotypes, and (right) a histogram showing the distribution of local environmental values where survivors are found. Effective phenotype-environment matching is indicated when individuals with similar phenotypes cluster spatially in regions with similar environmental values, and when the histogram of occupied environmental values matches the distribution of phenotypes.

```{r validation-s3, fig.width=8, fig.height=4}
# Scenario 3: Tolerance only
# Expect moderate phenotype-environment matching from passive processes
if (pop_s3 > 0) {
  check_habitat_match(sim_s3, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

In Scenario 3 (tolerance only, no habitat selection), survivors should show moderate spatial sorting. Individuals with low phenotypes (cool colors—blue/green) should tend to occupy low-value regions (also cool colors on landscape), while high phenotypes (warm colors—yellow/red) should occupy high-value regions. This matching arises passively from differential survival: individuals experience higher fitness when phenotype-environment mismatch is small, so natural selection favors occupation of matching environments even without active habitat selection.

```{r validation-s4, fig.width=8, fig.height=4}
# Scenario 4: Evolution added
# Expect similar or slightly improved matching from evolutionary optimization
if (pop_s4 > 0) {
  check_habitat_match(sim_s4, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

Scenario 4 (evolution added) should show similar or slightly enhanced matching compared to S3. Plasticity enables individuals to adjust phenotypes toward local conditions, potentially improving matches. Mutation allows evolutionary shifts in genotype_mean toward commonly experienced environmental values. The combined effect should be modest enhancement of the matching pattern established by tolerance alone.

```{r validation-s5, fig.width=8, fig.height=4}
# Scenario 5: Habitat selection added
# Expect strongest phenotype-environment matching from active spatial optimization
if (pop_s5 > 0) {
  check_habitat_match(sim_s5, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

Scenario 5 (habitat selection added) should show the strongest phenotype-environment matching. Active habitat selection (sampling_points=100) enables individuals to evaluate many locations and preferentially settle where fitness is high. This behavioral mechanism should produce clear spatial segregation: low-phenotype individuals concentrated in low-value regions, high-phenotype individuals in high-value regions, with minimal occupancy of mismatching environments.

```{r compute-correlations, echo=FALSE}
# Quantify phenotype-environment matching using correlation
# High positive correlation indicates strong matching
if (pop_s3 > 0 && "phenotype" %in% names(sim_s3$survivors) &&
    "habitat_quality" %in% names(sim_s3$survivors)) {
  cor_s3 <- cor(sim_s3$survivors$phenotype, 
                sim_s3$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s3 <- NA
}

if (pop_s4 > 0 && "phenotype" %in% names(sim_s4$survivors) &&
    "habitat_quality" %in% names(sim_s4$survivors)) {
  cor_s4 <- cor(sim_s4$survivors$phenotype, 
                sim_s4$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s4 <- NA
}

if (pop_s5 > 0 && "phenotype" %in% names(sim_s5$survivors) &&
    "habitat_quality" %in% names(sim_s5$survivors)) {
  cor_s5 <- cor(sim_s5$survivors$phenotype, 
                sim_s5$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s5 <- NA
}
```

The visualizations confirm phenotype-environment matching across all viable scenarios, validating TWoLife's implementation of the fitness model. Quantitatively, survivor phenotypes correlate positively with occupied environmental values: S3 (r = `r if(!is.na(cor_s3)) sprintf("%.2f", cor_s3) else "NA"`), S4 (r = `r if(!is.na(cor_s4)) sprintf("%.2f", cor_s4) else "NA"`), S5 (r = `r if(!is.na(cor_s5)) sprintf("%.2f", cor_s5) else "NA"`). `r if(!is.na(cor_s5) && !is.na(cor_s3) && cor_s5 > cor_s3) paste0("The correlation increases from S3 (tolerance only, r=", sprintf("%.2f", cor_s3), ") to S5 (with habitat selection, r=", sprintf("%.2f", cor_s5), "), confirming that active habitat selection enhances spatial matching beyond passive processes.") else if(!is.na(cor_s3)) paste0("The strong correlations across scenarios (all r>", sprintf("%.2f", min(cor_s3, cor_s4, cor_s5, na.rm=TRUE)), ") verify correct implementation of phenotype-environment matching.") else "These strong positive correlations verify that TWoLife correctly implements the phenotype-environment matching mechanism."`

# Understanding Simulation Output

## Object Structure

Simulation objects are returned as lists containing four components providing different levels of analytical detail. Understanding this structure enables efficient data extraction and analysis:

```{r output-structure}
# Examine top-level structure
names(sim_s5)

# Summary component provides aggregated final statistics
sim_s5$summary
```

The `summary` component is a list containing final population statistics: `final_population_size` (integer: number surviving at simulation end), `total_births` (integer: cumulative birth events), `total_deaths` (integer: cumulative death events), `total_dispersals` (integer: cumulative dispersal events), and `final_time` (numeric: simulation duration in time units). This component provides quick overview of population outcomes without requiring processing of detailed data.

## Accessing Individual-Level Data

The `survivors` component is a data frame where each row represents one surviving individual at simulation end. This enables analysis of trait distributions, spatial patterns, and phenotype-environment relationships among survivors:

```{r accessing-survivors}
# Individual-level data showing traits and locations
if (isTRUE(!is.null(sim_s5$survivors) && is.data.frame(sim_s5$survivors) && nrow(sim_s5$survivors) > 0)) {
  # Display first three survivors
  head(sim_s5$survivors, 3)
  
  # Columns include:
  # individual_id: unique identifier
  # genotype: genotype_mean value (genetic optimum)
  # genotype_sd: tolerance (niche width)
  # phenotype: current expressed value (can differ from genotype via plasticity)
  # x, y: spatial coordinates
  # habitat_quality: environmental value at current location
  # fitness: current survival probability based on phenotype-environment match
}
```

This data frame enables diverse analyses: trait distribution statistics (mean, variance, range of genotypes), spatial pattern analysis (clustering, dispersion), phenotype-environment correlation (matching strength), and fitness distribution (population viability indicators).

## Accessing Event History

The `events` component is a data frame recording every demographic event that occurred during the simulation. This complete history enables analysis of population dynamics, demographic rates over time, and detailed process tracking:

```{r accessing-events}
# Event history showing complete demographic record
if (isTRUE(!is.null(sim_s5$events) && is.data.frame(sim_s5$events) && nrow(sim_s5$events) > 0)) {
  # Display first three events
  head(sim_s5$events, 3)
  
  # Columns include:
  # time: when event occurred
  # event_type: "birth", "death", or "dispersal"
  # individual_id: which individual (births create new IDs, deaths remove IDs)
  # parent_id: for births, which individual reproduced (NA for deaths/dispersals)
  # x, y: location where event occurred
  # Plus trait values at time of event
  
  # Event counts by type
  table(sim_s5$events$event_type)
}
```

The events data enables temporal analysis: birth/death/dispersal rates over time, population growth trajectory reconstruction, lineage tracking (parent-offspring relationships), spatial dynamics (where events occur), and demographic rate variation over simulation duration.

## Accessing Parameters

The `parameters` component stores all input parameters, ensuring complete reproducibility. Any simulation can be exactly replicated by re-running with stored parameters:

```{r accessing-parameters}
# Parameters storage for reproducibility
if (!is.null(sim_s5$parameters)) {
  # Show structure (not full content—would be verbose)
  str(sim_s5$parameters, max.level = 1)
  
  # Example: extract landscape parameters
  names(sim_s5$parameters$landscape_params)
  
  # Parameters include:
  # landscape_params: landscape matrix and configuration
  # individual_params: initial population settings
  # genetic_params: trait values used
  # simulation_params: duration and stopping conditions
  # master_seed: ensures reproducibility
}
```

This complete parameter storage facilitates comparison across simulations (identify parameter differences), replication (re-run with identical settings), and archiving (store complete simulation specification).

# Parameters Reference

This comprehensive reference documents all parameters accepted by TWoLife functions, organized by parameter list. Each parameter includes description, valid values, defaults, and interpretation guidance.

## Landscape Parameters (`landscape_params` list)

- **habitat** (required): Numeric matrix of environmental values. For binary landscapes, use 0=matrix (unsuitable) and 1=habitat (suitable). For continuous landscapes, use values typically 0-1 representing environmental conditions (temperature, moisture, etc.). Dimensions determine landscape size (e.g., 15×15 matrix = 225 cells).

## Individual Parameters (`individual_params` list)

- **initial_population_size** (required): Integer specifying starting number of individuals. Must be positive. Typical values: 20-200. Larger populations reduce extinction risk but increase computation time.

- **initial_positions** (optional): Two-column matrix specifying starting (x,y) coordinates for each individual. If NULL (default), individuals are randomly placed in habitat cells (for binary landscapes) or random cells (for continuous landscapes). Custom placement enables testing specific initial configurations.

- **initial_ages** (optional): Vector of ages for initial individuals. If NULL (default), all start at age 0. Custom ages enable simulating populations with age structure.

## Genetic Parameters (`genetic_params` list, optional)

All genetic parameters accept either:
- Single value (applied to all individuals): e.g., `genotype_means = 0.5`
- Vector of length `initial_population_size` (individual-specific): e.g., `genotype_means = runif(40, 0.3, 0.7)`

- **genotype_means** (optional): Optimal environmental values. Range: typically 0-1 matching landscape range. Default: 0.5 for all individuals. Interpretation: environmental value where fitness is maximized (fitness=1.0 when phenotype matches environment).

- **genotype_sds** (optional): Niche widths/tolerance ranges. Range: >0, typically 0.05-0.3. Default: 0.1. Interpretation: standard deviation (σ) in Gaussian fitness function. Smaller values create specialists (narrow tolerance), larger values create generalists (broad tolerance). Value of 0.15 means ±0.3 (±2σ) range retains 95% of fitness.

- **mutation_rates** (optional): Probability of genetic change per reproduction. Range: 0-1, typically 0-0.1. Default: 0 (no evolution). Interpretation: per-birth probability that offspring genotype_mean differs from parent. Enables evolutionary adaptation when >0.

- **plasticities** (optional): Rate of phenotypic adjustment toward local environment. Range: 0-1. Default: 0 (no plasticity). Interpretation: per-timestep rate of phenotype shift toward local environmental value. 0=no adjustment (phenotype=genotype_mean), 1=complete immediate adjustment (phenotype=local environment within tolerance), 0.3=30% adjustment per step.

- **sampling_points** (optional): Habitat selection intensity. Range: ≥1 (integer). Default: 1 (random dispersal). Interpretation: number of locations evaluated before dispersal. 1=random movement (no selection), 10=moderate selectivity, 100=high selectivity (approaching optimal placement). Higher values enable better habitat matching but increase computation time.

## Simulation Parameters (`simulation_params` list)

- **max_events** (optional): Maximum number of demographic events (births + deaths + dispersals). Must be positive integer. Typical values: 250-1000. Simulation stops when this number is reached or population goes extinct. Alternative to max_time.

- **max_time** (optional): Maximum simulation duration in time units. Must be positive number. Alternative to max_events. Simulation stops when time reaches this value or population goes extinct.

- **min_population_size** (optional): Extinction threshold. Default: 0 (only true extinction stops simulation). If set to positive value (e.g., 5), simulation stops when population falls below this threshold, enabling extinction risk analysis.

- **max_population_size** (optional): Carrying capacity. Default: Inf (no limit). If set to finite value, prevents population from exceeding this number, implementing density dependence through recruitment limitation.

## Master Seed

- **master_seed** (required): Integer for reproducibility. Controls all random processes (initial placement, demographic events, mutations, habitat selection). Using identical master_seed with identical parameters produces exactly identical results. Different seeds produce independent realizations (different random events, same mechanisms).

# Computational Considerations

## Performance

Simulation speed depends on multiple factors that users can control through parameter choices:

1. **Landscape size**: Computational cost scales quadratically with linear dimension. A 15×15 landscape (225 cells) is 4× faster than 30×30 (900 cells), which is 4× faster than 60×60 (3600 cells). Recommendation: start with smaller landscapes (15-30 cells per dimension) for exploration, increase to 50-100 for publication analyses.

2. **Population size**: Cost scales linearly with number of individuals tracked. 50 individuals is 2× faster than 100, which is 2× faster than 200. Recommendation: balance ecological realism (larger populations reduce extinction risk and demographic stochasticity) against computational cost.

3. **Habitat selection**: Cost scales linearly with `sampling_points` value. sampling_points=100 is 100× slower than sampling_points=1 because each dispersal evaluates 100 locations vs. 1. Recommendation: use sampling_points=1 for quick exploration, increase to 10-100 when habitat selection is scientifically important.

4. **Simulation duration**: Cost scales linearly with `max_events` or `max_time`. 1000 events takes 2× as long as 500 events. Recommendation: determine minimum duration needed for dynamics to equilibrate, then add 20-50% margin.

**Typical performance:** On standard laptop (2023):
- Small (15×15, N=50, 500 events, sampling=1): ~1-2 seconds
- Medium (30×30, N=100, 1000 events, sampling=10): ~5-15 seconds
- Large (50×50, N=200, 2000 events, sampling=100): ~30-120 seconds

## Memory Usage

Memory scales with event history storage, which grows linearly with `max_events`. Each event requires ~200-500 bytes depending on tracked attributes. For memory-intensive applications with very long simulations (>50,000 events), consider:

1. Running shorter simulations to equilibrium rather than indefinitely
2. Periodically extracting and saving results, then restarting
3. Using smaller populations when scientifically justified

Typical memory usage: <100 MB for most applications, <1 GB for extreme cases (very long simulations or many replicates stored in memory).

## Reproducibility

Complete reproducibility requires three conditions:

1. **Identical `master_seed`**: Same seed guarantees identical random number sequences
2. **Same TWoLife version**: Algorithm changes between versions may affect results. Check version with `packageVersion("TWoLife")`. Report version in publications.
3. **Same R version**: Numerical precision can vary across R versions. For critical reproducibility (publications, archiving), report R version (`R.version.string`) and consider using same R version for replication.

All parameters are stored in simulation output enabling exact replication:

```{r reproducibility-example, eval=FALSE}
# Replicate a simulation exactly using stored parameters
sim_replicate <- twolife_simulation(
  landscape_params = sim_s5$parameters$landscape_params,
  individual_params = sim_s5$parameters$individual_params,
  genetic_params = sim_s5$parameters$genetic_params,
  simulation_params = sim_s5$parameters$simulation_params,
  master_seed = sim_s5$parameters$master_seed
)

# Results should be identical
identical(sim_replicate$summary, sim_s5$summary)  # Should return TRUE
```

## Parallelization

For parameter sweeps or Monte Carlo replication, simulations can be parallelized using R's parallel processing capabilities. Each simulation is independent, enabling perfect parallelization:

```{r parallelization-example, eval=FALSE}
library(parallel)

# Detect available cores (leave 1 for system)
n_cores <- detectCores() - 1

# Example: replicate Scenario 3 (tolerance) 100 times with different seeds
# to estimate distribution of population outcomes
n_reps <- 100
results <- mclapply(1:n_reps, function(i) {
  twolife_simulation(
    landscape_params = list(habitat = continuous_landscape),
    individual_params = list(initial_population_size = 40),
    genetic_params = list(
      genotype_means = runif(40, 0.3, 0.7),  # New random genotypes each rep
      genotype_sds = rep(0.15, 40)
    ),
    simulation_params = list(max_events = 250),
    master_seed = 1000 + i  # Different seed per replicate
  )
}, mc.cores = n_cores)

# Extract and analyze distribution of outcomes
final_sizes <- sapply(results, function(x) x$summary$final_population_size)
hist(final_sizes, breaks = 20, col = "lightblue", border = "white",
     main = "Distribution of Final Population Sizes\n(100 Replicates)",
     xlab = "Final N")
abline(v = mean(final_sizes), col = "red", lwd = 2, lty = 2)
text(mean(final_sizes), par("usr")[4]*0.9, 
     paste0("Mean = ", round(mean(final_sizes), 1)), pos = 4, col = "red")
```

# Discussion

## What TWoLife Enables

**Continuous environmental representation:** Unlike most individual-based models that discretize space into categorical habitat types (suitable vs. unsuitable) [@DeAngelis2005], TWoLife handles continuous environmental gradients representing realistic spatial variation in conditions like temperature, moisture, or resource availability. This enables investigation of species responses to gradual environmental transitions, edge effects in continuous space, and adaptive matching processes that would be obscured by discrete classification.

**Individual-level genetic architecture:** Each individual possesses unique genetic values for optimal conditions (genotype_mean), niche widths (genotype_sd), mutation rates, plasticity coefficients, and behavioral parameters—all heritable, mutable, and mechanistically implemented through explicit fitness calculations. This individual-level representation enables investigation of how genetic variation structures population responses to environmental heterogeneity, tracking lineages, analyzing trait evolution, and testing hypotheses about necessary genetic diversity.

**Phenotype-environment matching framework:** Fitness emerges dynamically from Gaussian matching between individual traits and local conditions rather than pre-assigned habitat quality. This mechanistic approach allows investigation of matching processes, local adaptation trajectories, and niche evolution without assuming fitness landscapes a priori. The explicit fitness function (exp(-(phenotype-environment)²/(2×tolerance²))) enables quantitative predictions about survival probability given any trait-environment combination.

**Flexible mechanism integration:** Users control which mechanisms operate (genetic variation, tolerance, plasticity, evolution, behavior) through parameter specification, enabling systematic hypothesis testing about mechanism necessity and sufficiency. This factorial capability supports experimental designs isolating mechanism effects, as demonstrated in our five-scenario analysis where progressive mechanism addition revealed their relative importance and interactions.

**Complete transparency:** All individual traits, locations, fitness values, and demographic events are tracked throughout simulations and stored in accessible data frames. This supports validation (verify mechanisms operate correctly through phenotype-environment correlation analysis), detailed analysis of emergent patterns (spatial distributions, trait evolution), and lineage tracking (parent-offspring relationships through event history). The complete transparency distinguishes TWoLife from "black box" models where internal processes are opaque.

# Conclusion

**TWoLife** provides a flexible framework for simulating populations as collections of genetically variable individuals inhabiting spatially heterogeneous landscapes. Through systematic experimentation, this vignette demonstrated:

**Core capabilities:**
- Generation of discrete habitat patches and continuous environmental gradients with realistic spatial structure through fractal algorithms
- Individual-level tracking of genetic traits (optimal values, tolerance, mutation, plasticity, behavior), phenotypes, and fitness through complete demographic histories
- Flexible integration of evolutionary and behavioral mechanisms through parameter control, enabling factorial experimental designs
- Complete reproducibility through parameter storage and master seed control, with computational efficiency suitable for parameter exploration (typical simulations complete in seconds to minutes)

**Key findings from our simulations:**
- Niche width (tolerance ranges, genotype_sd parameter) is necessary and sufficient for persistence in heterogeneous environments (Scenarios 1-3). The S2→S3 transition—adding tolerance while holding genetic diversity constant—enabled the shift from extinction (N=0) to viability (N=`r pop_s3`).
- Genetic diversity in optimal values alone, without physiological flexibility (tolerance), is insufficient for viability in continuous landscapes (Scenario 2: N=0 despite 40 different genotypes). Continuous space rarely provides exact phenotype-environment matches required by specialists with zero tolerance.
- Evolution (mutation + plasticity) and behavior (habitat selection) enhance survival but cannot compensate for lack of fundamental tolerance (Scenarios 4-5). These mechanisms add `r pop_s5 - pop_s3` individuals (`r sprintf("%.1f%%", (pop_s5-pop_s3)/pop_s3*100)` increase) beyond tolerance alone—substantial but secondary to tolerance's enabling effect.
- Mechanisms interact in hierarchical rather than simply additive fashion: tolerance is prerequisite for viability, with evolution and behavior providing enhancements that amplify tolerance's effects rather than operating independently.

**Scientific value:**
- Enables investigation of questions that are challenging for models lacking either individual variation or continuous spatial heterogeneity: How does tolerance breadth affect habitat availability? How do phenotype-environment matching processes structure populations? When is genetic diversity necessary vs. sufficient?
- Supports hypothesis testing about mechanism necessity and sufficiency through systematic parameter manipulation, as demonstrated by the five-scenario experimental design isolating tolerance, evolution, and behavior effects.
- Provides quantitative predictions about population outcomes emerging from individual-level processes and trait-environment interactions, with explicit fitness functions enabling calculation of expected survival probability for any trait-environment combination.
- Facilitates reproducible, mechanistically explicit research workflows through complete parameter storage, output transparency, and helper functions for result extraction and visualization.

By integrating spatial heterogeneity and individual variation within a unified simulation framework, TWoLife advances capacity to understand population dynamics, evolutionary processes, and conservation strategies in realistic ecological contexts where environments vary continuously and individuals differ genetically in their responses to conditions.

# References

::: {#refs}
:::

