---
title: "TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes"
author: "Lucas Freitas"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
bibliography: references.bib
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  cache = FALSE
)
```

# Introduction

The **TWoLife** package implements individual-based simulations of
populations inhabiting spatially heterogeneous landscapes. Unlike
traditional models that assume genetic uniformity within populations,
TWoLife explicitly represents individual variation in traits that
determine ecological outcomes. As a consequence, the package allows
researchers to investigate how preexisting genetic diversity interacts
with landscape structure to influence population persistence
[@Bolnick2003; @Lynch1998].

The package addresses a fundamental limitation of ecological theory: the
assumption that individuals within a population perceive and exploit
environments in identical ways. This assumption, while simplifying
mathematical analysis, may not depict biologically realistic scenarios
[@Chesson2000; @Wiens1976]. In reality, individuals differ in their
optimal environmental conditions, tolerance ranges, and behavioral
strategies. This in turn means that environmental changes may favor some
individuals to the detriment of others, with consequences for
population-level outcomes that cannot be predicted from species-level
averages alone.

TWoLife enables researchers to:

1.  Generate landscapes with **continuous environmental gradients**
    representing variation in conditions across space, or **discrete
    habitat patches** embedded in unsuitable matrix
2.  Model **individual genetic variation** in optimal environmental
    values, tolerance ranges (niche width), and behavioral strategies
    such as habitat selection
3.  Implement **evolutionary and adaptive mechanisms** including
    mutation (heritable genetic changes), phenotypic plasticity
    (non-heritable developmental noise), and natural selection through
    differential survival
4.  Track **phenotype-environment interactions** where fitness emerges
    dynamically from the match between individual traits and local
    conditions, rather than being pre-assigned by habitat type
5.  Analyze **emergent population dynamics** arising from
    individual-level processes of birth, death, dispersal, and trait
    evolution

This vignette demonstrates TWoLife's capabilities through two
complementary analyses that progressively build understanding of the
package's functionality and scientific applications:

**Part 1: Basic Workflow Demonstration** (Section 5) introduces the main
function structure and parameter organization using discrete
habitat-matrix landscapes. This simpler scenario—where space is divided
into suitable habitat and unsuitable matrix—allows readers to grasp
input requirements and output structure before confronting the added
complexity of continuous environmental variation.

**Part 2: Main Analysis** (Section 6) showcases TWoLife's core
innovation: modeling populations where fitness emerges from
phenotype-environment matching along continuous gradients. Through a
progressive five-scenario comparison, we isolate the effects of genetic
diversity, tolerance, evolution, and behavior on population outcomes.
This analysis demonstrates how the package can address questions about
which mechanisms are necessary for persistence under environmental
heterogeneity.

Together, these analyses illustrate both fundamental usage patterns and
the package's capacity to investigate eco-evolutionary dynamics in
spatially structured populations.

# Package Setup

Before executing any simulations, we load the package and establish a
seed for reproducibility:

```{r load-package}
library(TWoLife)

# Set seed for reproducible results across all subsequent operations
set.seed(42)
```

# Key Concepts

## Landscapes

Spatial environments in TWoLife are represented as numeric matrices
where each cell contains an environmental value. The package supports
two fundamentally different landscape types that determine how
environmental variation structures individual fitness:

-   **Continuous landscapes**: Environmental values vary along
    gradients, typically ranging from 0.0 to 1.0. These values represent
    continuous variation in conditions such as temperature (e.g., 0°C to
    30°C rescaled to 0-1), soil moisture (0% to 100%), or resource
    availability. In continuous landscapes, no locations are inherently
    unsuitable. Rather, suitability emerges dynamically from the
    interaction between individual phenotypes and local environmental
    values through Gaussian matching (explained in the Fitness section
    below). This means that a cell with value 0.3 is not intrinsically
    "better" or "worse" than a cell with value 0.7—suitability depends
    on whether individuals in the population possess phenotypes adapted
    to those particular values.

-   **Discrete landscapes**: Space is divided into binary categories
    where each cell is classified as either suitable habitat (value=1)
    or unsuitable matrix (value=0). This representation is common in
    fragmented landscapes where habitat patches are embedded in a
    surrounding matrix that cannot support populations. In discrete
    landscapes, individuals can persist only in habitat cells, while
    matrix cells are immediately lethal regardless of individual traits.
    This binary classification corresponds to the traditional
    patch-matrix paradigm in landscape ecology [@Fahrig2003].

Landscapes are generated using `create_fractal_landscape()`, which
produces realistic spatial patterns with self-similar structure across
scales [@Justeau-Allaire2022]. The fractal algorithm ensures that
pattern complexity—the degree of patchiness versus smoothness—remains
similar whether the landscape is viewed at fine resolution (individual
cells) or coarse resolution (blocks of cells). This property mimics
natural spatial processes where environmental structure often exhibits
scale-invariant patterns.

## Fitness: How Traits Determine Survival

Survival probability in TWoLife is determined by Gaussian matching—a
mathematical function that quantifies how well an individual's phenotype
matches local environmental conditions. This fitness framework differs
fundamentally from models where habitat quality is pre-assigned by
location type (e.g., habitat cells support survival, matrix cells do
not). Instead, fitness emerges dynamically from trait-environment
interactions:

$$\text{fitness} = \exp\left(-\frac{(\text{phenotype} - \text{environment})^2}{2 \times \text{genotype\_sd}^2}\right)$$

where:

-   **phenotype** is the individual's expressed trait value
    (genotype_mean plus developmental noise determined by the plasticity
    parameter, sampled once at birth)
-   **environment** is the environmental value at the cell where the
    individual currently resides (ranging from 0 to 1 in continuous
    landscapes, or 0/1 in binary landscapes)
-   **genotype_sd** is the individual's tolerance parameter (niche
    width)

This Gaussian function produces a bell-shaped fitness curve centered on
the individual's phenotype. When phenotype perfectly matches the local
environment, the numerator equals zero and fitness equals 1.0,
representing maximum survival probability. As the phenotype-environment
mismatch increases in either direction, fitness declines exponentially.
The rate of decline is controlled by genotype_sd (tolerance parameter, 
see Individuals section for details): smaller values produce specialists 
requiring close environmental matches, while larger values produce 
generalists tolerating diverse conditions.

This fitness framework has important implications for how populations
respond to environmental heterogeneity. In models with pre-assigned
habitat quality, fitness depends solely on location type—habitat cells
are "good" and matrix cells are "bad" for all individuals equally. In
TWoLife, fitness depends on the match between individual-specific
phenotypes and local conditions. This means that different individuals
perceive the same landscape differently, and spatial heterogeneity can
maintain genetic variation by favoring different phenotypes in different
locations [@Levins1968].

## Individuals

Each individual in TWoLife is a simulated organism characterized by
heritable genetic traits. Unlike models where fitness is
location-dependent but individual-independent, fitness in TWoLife
emerges from phenotype-environment matching as described above. As a
consequence, populations can contain diverse individuals who differ in
their ecological niches and respond differently to environmental change.

Individuals are characterized by five genetic attributes that together
determine ecological and evolutionary outcomes:

-   **`genotype_mean`** (Optimal environmental value): The environmental
    condition at which the individual achieves maximum fitness,
    representing the genetically-determined optimal niche position.
    Values typically range from 0 to 1, matching the landscape's
    environmental scale. For example, an individual with
    genotype_mean=0.3 is genetically adapted to environmental value 0.3
    (e.g., cool temperatures if the gradient represents temperature).
    When an individual's phenotype (genotype_mean plus noise from
    plasticity) exactly matches the local environmental value, fitness
    equals to its maximum. This parameter thus determines where on the
    environmental gradient each individual performs best.

-   **`genotype_sd`** (Niche width/tolerance): The breadth of
    environmental conditions the individual can tolerate, represented
    mathematically as the standard deviation (σ) in the Gaussian fitness
    function described above. This parameter controls how steeply
    fitness declines as environmental conditions deviate from the
    optimum. Smaller values (e.g., genotype_sd=0.05) indicate
    specialists with narrow tolerance ranges—fitness drops rapidly with
    small environmental mismatches, making these individuals vulnerable
    to environmental change but highly efficient in optimal conditions.
    Larger values (e.g., genotype_sd=0.3) indicate generalists with
    broad tolerance—fitness declines gradually even with substantial
    environmental mismatches, allowing these individuals to persist
    across diverse conditions albeit with lower peak fitness. A
    genotype_sd of 0.15 means approximately 95% of fitness is retained
    within ±0.3 units of the optimal value (±2σ in statistical terms).

-   **`plasticity`** (Phenotypic plasticity): Controls non-heritable
    phenotypic variation arising from developmental or environmental
    noise. This parameter determines the standard deviation (ψ) of
    random variation added to an individual's genotype at birth to
    produce its phenotype, which then remains fixed for the individual's
    lifetime. Importantly, the phenotype (not genotype) determines
    fitness and habitat selection, while only the genotype is
    transmitted to offspring. This distinction allows modeling of
    developmental variation that affects individual ecology but is not
    inherited. Mathematically, the relationship can be expressed as:
    $p = g + \varepsilon_{\text{plasticity}}$ where
    $\varepsilon_{\text{plasticity}} \sim N(0, \psi)$ and $\psi$ =
    plasticity parameter.

-   **`mutation_rate`** (Mutation rate): Controls heritable genetic
    variation transmitted across generations. This parameter determines
    the standard deviation (μ_r) of mutations added to the offspring's
    genotype at each birth event. Unlike plasticity, which affects
    phenotype but not inheritance, mutations modify the genotype itself
    and these modifications are passed to future generations. This
    enables evolutionary adaptation—populations can shift their genetic
    composition in response to selection pressures. The underlying
    mathematical model is: $g_{\text{offspring}} = g_{\text{parent}} +
    \varepsilon_{\text{mutation}}$ where $\varepsilon_{\text{mutation}}
    \sim N(0, \mu_r)$ and $\mu_r$ = mutation_rate parameter.

-   **`sampling_points`** (Habitat selection intensity): The number of
    potential dispersal locations an individual evaluates before
    deciding where to move. When sampling_points is set to 0 or 1,
    individuals move to randomly chosen locations without evaluation,
    representing passive dispersal mechanisms. These two values are
    conceptually equivalent in producing passive dispersal but differ in
    implementation—0 triggers a random walk algorithm while 1 samples a
    single random location. As sampling_points increases, individuals
    gain the capacity to assess and compare multiple locations before
    settling, selecting among them using a softmax function weighted by
    expected fitness. Higher values enable increasingly sophisticated
    habitat selection and increase computation time linearly, but the
    softmax process retains some randomness to prevent unrealistic
    determinism where all individuals always select the single best
    available cell.

All five attributes are heritable, enabling evolutionary dynamics and
potential local adaptation over multiple generations.

# Package Overview

## Main Function

TWoLife simulations are executed through a single main function that
accepts five components organized to separate spatial, demographic,
genetic, temporal, and stochastic aspects of the model. This
organization reflects the structure of individual-based models more
generally, where populations are defined by their environment
(landscape), initial configuration (individuals), heritable variation
(genetics), and temporal dynamics (simulation parameters), with
stochasticity controlled through seeding [@Grimm2005].

The four parameter lists are:

-   **landscape_params**: A list containing spatial environment
    configuration, specifically the habitat matrix and optionally
    environmental values
-   **individual_params**: A list containing population initialization
    settings (starting population size and positions)
-   **genetic_params**: An optional list specifying individual variation
    in genetic traits (optimal values, tolerance, mutation rates,
    plasticity, and behavior)
-   **simulation_params**: A list containing simulation control and
    stopping conditions (duration limits)

The fifth component is **master_seed**, an integer value that ensures
complete reproducibility by controlling all random processes in the
simulation, from initial individual placement to demographic event
ordering to mutation directions.

The function structure is:

```{r eval=FALSE}
twolife_simulation(
  landscape_params,
  individual_params,
  genetic_params,
  simulation_params,
  master_seed
)
```

Each parameter list is a standard R list containing named elements. The
`landscape_params` list must include a habitat matrix defining the
spatial environment. The `individual_params` list specifies initial
population size and optional starting configurations.

**Important note on genetic_params**: This list is optional. When
`genetic_params` is omitted, TWoLife applies default values designed
specifically for binary landscapes where habitat=1 and matrix=0. Under
these defaults, all individuals have genotype_mean=1 (matching habitat
value), genotype_sd=0 (zero tolerance, requiring exact environmental
matches), mutation_rate=0 (no evolution), plasticity=0 (no phenotypic
noise), and sampling_points=1 (random dispersal with no habitat
selection). These defaults work well for exploring habitat-matrix
simulations without genetic complications, as they create genetically
uniform populations that survive in habitat cells but not matrix cells.
However, these same defaults typically produce extinction in continuous
landscapes where exact environmental matches are rare. As a consequence,
explicit genetic_params specification is essential when working with
continuous environmental gradients (demonstrated in Section 6).

The `simulation_params` list controls simulation duration through
`max_events` (maximum number of demographic events). The
`master_seed` ensures all random processes—initial placement when
positions aren't specified, which individual reproduces/dies/disperses
next, mutation direction and magnitude, plasticity noise, and movement
events—produce identical results
when re-run with the same seed value. Using identical master_seed with
identical parameters produces exactly identical results, while using
different seeds with identical parameters produces independent
realizations. This distinction is analogous to experimental trials: the
processes are identical but random outcomes differ, allowing
quantification of outcome variability under fixed conditions.

## Simulation Output

Simulations return a list object containing four components that provide
different levels of detail about population outcomes. This structure
balances the need for quick summaries (summary component), detailed
individual-level data (survivors component), complete demographic
records (events component), and reproducibility (parameters component):

-   **`summary`**: A list of final population statistics including
    `final_population_size` (number surviving at simulation end),
    `total_births` (cumulative birth events), `total_deaths` (cumulative
    death events), `total_dispersals` (cumulative dispersal events), and
    `final_time` (simulation duration). This component provides quick
    assessment of population outcomes without requiring data processing.

-   **`survivors`**: A data frame where each row represents one
    surviving individual at simulation end. Columns include
    `individual_id`, `genotype` (genotype_mean value), `genotype_sd`
    (niche width), `phenotype` (expressed environmental optimum), `x`
    and `y` (spatial coordinates). This component enables analysis of
    trait distributions, spatial patterns, and phenotype-environment
    matching among survivors. When populations go extinct, this
    component may be NULL or an empty dataframe.

-   **`events`**: A data frame recording every demographic event that
    occurred during the simulation. The level of detail depends on the
    `history_detail` parameter (set in `simulation_params`). At minimum
    (`history_detail="minimal"`), each row documents one event with
    columns: `time` (when event occurred), `event_type` (0=death,
    1=birth, 2=dispersal, 3=emigration, -1=initial state), and
    `individual_id`. Standard detail (`history_detail="standard"`, the
    default) additionally includes `patch_id`, `x` and `y` coordinates,
    and `genotype`. Full detail (`history_detail="full"`) further adds
    `phenotype` and `width` (genotype_sd). This complete history
    enables analysis of population dynamics, demographic rates over
    time, and lineage tracking.

-   **`parameters`**: A list storing all input parameters
    (landscape_params, individual_params, genetic_params,
    simulation_params, master_seed). This ensures complete
    reproducibility—simulations can be exactly replicated by re-running
    with stored parameters. It also enables systematic comparison across
    simulations with different parameter configurations.

To demonstrate this output structure, we create a minimal example
consisting of a 10×10 uniform habitat with 20 individuals running for
100 demographic events:

```{r create-example-sim}
# Create simple example: 10×10 uniform habitat, 20 individuals, 100 events
example_sim <- twolife_simulation(
  landscape_params = list(habitat = matrix(1, nrow = 10, ncol = 10)),
  individual_params = list(initial_population_size = 20),
  simulation_params = list(max_events = 100),
  master_seed = 1
)
```

## Accessing Summary Statistics

The `summary` component contains high-level population outcomes as a
named list, providing quick assessment of simulation results without
requiring detailed data processing:

```{r accessing-summary}
# Population-level outcomes
example_sim$summary
```

The summary includes `final_population_size` (integer: number
surviving), `total_births` (integer: cumulative birth events),
`total_deaths` (integer: cumulative death events), `total_dispersals`
(integer: cumulative dispersal events), and `final_time` (numeric:
simulation duration in time units). Together, these statistics
characterize demographic processes and population outcomes at the
coarsest scale.

## Accessing Individual-Level Data

The `survivors` component is a data frame where each row represents one
surviving individual at simulation end. This structure enables analysis
of trait distributions, spatial patterns, and phenotype-environment
relationships among survivors—questions that require individual-level
resolution but not complete demographic histories.

The survivors data frame contains the following columns:

-   **individual_id**: Unique identifier assigned to each individual at
    birth
-   **genotype**: The genotype_mean value representing the individual's
    genetic optimum
-   **genotype_sd**: Tolerance or niche width parameter
-   **phenotype**: Current expressed value (may differ from genotype
    through plasticity noise added at birth)
-   **x, y**: Spatial coordinates indicating current location in the
    landscape matrix

This data structure enables diverse analyses including trait
distribution statistics (mean, variance, range of genotypes and
phenotypes), spatial pattern analysis (clustering, dispersion, spatial
autocorrelation), and phenotype-environment correlation (strength of
matching among survivors).

We examine the survivors data as follows:

```{r accessing-survivors}
# Individual-level data showing traits and locations
# Check survivors exist (simulations can produce extinction where survivors is NULL/empty)
if (isTRUE(!is.null(example_sim$survivors) && is.data.frame(example_sim$survivors) && nrow(example_sim$survivors) > 0)) {
  # Display first three survivors
  head(example_sim$survivors, 3)
}
```

## Accessing Event History

The `events` component is a data frame recording every demographic event
that occurred during the simulation. This complete history enables
analysis of population dynamics over time, demographic rates, and
detailed process tracking—questions that require temporal resolution
beyond simple summary statistics.

The events data frame contains the following columns:

-   **time**: When the event occurred (in simulation time units, which
    accumulate according to exponential waiting times)
-   **event_type**: The type of demographic event ("birth", "death", or
    "dispersal")
-   **individual_id**: Which individual experienced the event (births
    create new IDs, deaths remove IDs from the population, dispersals
    modify existing individual locations)
-   **parent_id**: For birth events, identifies which individual
    reproduced (NA for deaths and dispersals, enabling lineage tracking)
-   **x, y**: Location coordinates where the event occurred
-   Additional columns containing trait values (genotype, phenotype,
    fitness) at the time of the event

This complete event record enables temporal analysis including
birth/death/dispersal rates over time (how demographic processes change
as populations grow or decline), population growth trajectory
reconstruction (plotting population size versus time), lineage tracking
through parent-offspring relationships, spatial dynamics showing where
events concentrate, and analysis of how demographic rates vary
throughout simulation duration.

We examine the event history as follows:

```{r accessing-events}
# Event history showing complete demographic record
if (isTRUE(!is.null(example_sim$events) && is.data.frame(example_sim$events) && nrow(example_sim$events) > 0)) {
  # Display first three events
  head(example_sim$events, 3)

  # Event counts by type
  table(example_sim$events$event_type)
}
```

## Accessing Parameters

The `parameters` component stores all input parameters, ensuring
complete reproducibility. Any simulation can be exactly replicated by
re-running with stored parameters, which is essential for computational
research where reproducibility is a fundamental requirement
[@Grimm2005]:

```{r accessing-parameters}
# Parameters storage for reproducibility
if (!is.null(example_sim$parameters)) {
  # Show structure (not full content—would be verbose)
  str(example_sim$parameters, max.level = 1)

  # Example: extract landscape parameters
  names(example_sim$parameters$landscape_params)

  # Parameters include:
  # landscape_params: landscape matrix and configuration
  # individual_params: initial population settings
  # genetic_params: trait values used (or NULL if defaults applied)
  # simulation_params: duration and stopping conditions
  # master_seed: ensures reproducibility
}
```

This complete parameter storage facilitates comparison across
simulations (identify parameter differences driving outcome variation),
replication (re-run with identical settings), and archiving (store
complete simulation specification for long-term reproducibility).

# Basic Workflow Demonstration

Before exploring TWoLife's core capabilities (individual variation in
continuous landscapes), we demonstrate basic workflow using a simpler
scenario: discrete habitat-matrix landscapes where suitable habitat
patches are embedded in an unsuitable matrix (the areas between patches
that cannot support populations). This introductory example demonstrates
the main function structure, parameter organization, and output format
using the classic SLOSS (Single Large or Several Small) conservation
debate: whether a single large habitat reserve better supports
populations than several small reserves with the same total area
[@Diamond1975]. This question has substantial implications for
conservation planning in fragmented landscapes [@Fahrig2003].

## Creating Landscapes

TWoLife provides `create_fractal_landscape()` for generating spatial
patterns with realistic spatial structure. The fractal algorithm creates
landscapes where pattern complexity is self-similar across spatial
scales—meaning the degree of patchiness appears similar whether viewing
individual cells or blocks of cells, mimicking natural environmental
processes that often generate scale-invariant patterns [@Milne1992].

The function accepts several key parameters that control landscape
properties. For binary (discrete) landscapes, the most important are:

-   `cells_per_row`: Landscape resolution, determining the total number
    of cells (e.g., 15 produces a 15×15 grid = 225 total cells)
-   `fractality`: Controls spatial autocorrelation through the power
    spectrum of the fractal algorithm. Values near 0 produce patchy,
    fine-grained heterogeneity with high small-scale variation—many
    small patches scattered throughout the landscape. Values near 1
    produce smooth gradients with broad-scale patterns—large contiguous
    areas of similar conditions. The intermediate value of 0.5 creates
    self-similar structure where pattern complexity is similar across
    spatial scales, typical of many natural environmental patterns. For
    most applications, fractality between 0.3-0.7 produces realistic
    heterogeneity that balances local variation with regional structure.
-   `habitat_proportion`: For binary landscapes, this specifies the
    fraction of cells classified as suitable habitat (value=1). The
    remaining fraction becomes matrix (value=0). Setting this to 1.0
    creates 100% habitat (pristine landscape with no matrix), while 0.2
    creates 20% habitat embedded in 80% matrix (highly fragmented
    landscape).
-   `min_value` and `max_value`: Not used for binary landscapes (which
    always range from 0 to 1), but important for continuous landscapes
    (discussed later in Section 6).

We create three landscape configurations to test the SLOSS question:

```{r sloss-landscapes}
# Pristine landscape: 100% suitable habitat, no fragmentation
set.seed(100)
pristine_landscape <- create_fractal_landscape(
  cells_per_row = 15,      # 15×15 = 225 total cells
  fractality = 0.5,        # Intermediate spatial structure
  habitat_proportion = 1.0 # 100% habitat (no matrix)
)

# Pre-configured SLOSS landscapes from package data
# Both have nearly the same habitat area (~20%) but different spatial configurations
single_large_patch <- single_large      # 20% coverage concentrated in 1 large patch
several_small_patches <- several_small  # 20% coverage distributed across multiple small patches
```

The figure below visualizes these three landscape configurations. Dark
green indicates suitable habitat (value=1), while white indicates
unsuitable matrix (value=0). In the pristine landscape (left),
continuous green coverage provides habitat everywhere—individuals can
move freely across the entire landscape without encountering matrix. In
single large (center), approximately 20% of cells form one contiguous
patch in the landscape center, creating a core area with minimal edge.
This configuration provides continuous habitat within the patch but
requires dispersal across matrix to reach it. In several small (right),
approximately 20% of cells are distributed across multiple isolated
patches, creating numerous edges and requiring dispersal between
fragments. These spatial differences have demographic consequences:
single large patches support reproduction within continuous habitat,
while several small patches require successful inter-patch dispersal for
population persistence. All three will be initialized with 100
individuals to test how spatial arrangement affects population outcomes
when habitat amount differs (pristine versus fragmented) and when
habitat amount is held constant but configuration varies (single large
versus several small):

```{r visualize-sloss, fig.width=9, fig.height=3, echo=FALSE}
par(mfrow = c(1, 3), mar = c(4, 4, 3, 2))
plot_landscape(pristine_landscape,
                            main = "Pristine\n(100% habitat)",
                            colors = "habitat")
plot_landscape(single_large_patch,
                            main = "Single Large\n(20% habitat)",
                            colors = "habitat")
plot_landscape(several_small_patches,
                            main = "Several Small\n(20% habitat)",
                            colors = "habitat")
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Running Simulations

The core `twolife_simulation()` function requires four parameter lists
plus a master seed. Each list is a standard R list containing named
elements that control different simulation aspects:

**landscape_params**: A list containing the habitat matrix and optional
environmental values. For this basic example, we provide only the
habitat component—a matrix where 1 represents suitable habitat and 0
represents unsuitable matrix. The function interprets this binary matrix
as a discrete landscape where individuals can survive only in habitat
cells.

**individual_params**: A list controlling initial population
configuration. The `initial_population_size` element specifies how many
individuals to place at simulation start (here, 100). An additional
optional element is `initial_positions` (custom starting locations;
default is random placement in habitat cells). For this example, we use
only the population size and accept default random placement.

**genetic_params**: Omitted in this example, which applies default values
appropriate for binary landscapes (see Section 4.1 for details). These
defaults create genetically uniform populations suitable for exploring
landscape structure effects without genetic complications.

**simulation_params**: A list controlling simulation duration and
stopping conditions. The `max_events` element specifies how many
demographic events (births, deaths, dispersals combined) to execute
before stopping. Here we use 300 events, sufficient to observe
population dynamics without excessive computation.

**master_seed**: An integer that controls all random processes (see
Section 4.1 for details). Using identical master_seed with identical
parameters produces exactly identical results, while different seeds
produce independent realizations of the same scenario. Here we use
different seeds (10, 20, 30) to ensure each landscape is an independent
realization.

```{r run-sloss-sims}
# Simulate pristine landscape (baseline: 100% habitat)
sim_pristine <- twolife_simulation(
  landscape_params = list(habitat = pristine_landscape),
  individual_params = list(initial_population_size = 100),
  # genetic_params omitted: uses defaults appropriate for binary landscapes
  simulation_params = list(max_events = 300),
  master_seed = 10
)

# Simulate single large patch (20% habitat, aggregated)
sim_single_large <- twolife_simulation(
  landscape_params = list(habitat = single_large_patch),
  individual_params = list(initial_population_size = 100),
  # genetic_params omitted: uses defaults
  simulation_params = list(max_events = 300),
  master_seed = 20
)

# Simulate several small patches (20% habitat, fragmented)
sim_several_small <- twolife_simulation(
  landscape_params = list(habitat = several_small_patches),
  individual_params = list(initial_population_size = 100),
  # genetic_params omitted: uses defaults
  simulation_params = list(max_events = 300),
  master_seed = 30
)
```

## Comparing Outcomes

We can compare final population sizes across the three landscape
configurations to assess how habitat amount and spatial configuration
influence population outcomes:

```{r compare-sloss}
final_pops <- c(
  Pristine = sim_pristine$summary$final_population_size,
  Single_Large = sim_single_large$summary$final_population_size,
  Several_Small = sim_several_small$summary$final_population_size
)

final_pops
```

To visualize population dynamics over time, we use the
`population_size()` helper function, which processes the events
dataframe to calculate population size at each time point. This function
returns a dataframe with 'time' and 'population_size' columns suitable
for plotting, enabling visualization of population trajectories rather
than just endpoint comparisons:

```{r sloss-dynamics, fig.width=9, fig.height=5}
par(mfrow = c(1, 2), mar = c(5, 4, 3, 2))

# Final population sizes comparison
barplot(final_pops,
        main = "Final Population Sizes",
        ylab = "Population Size (N)",
        col = c("darkgreen", "steelblue", "coral"),
        las = 1)
abline(h = 100, lty = 2, col = "gray50")
text(0.7, 105, "Initial N=100", pos = 4, cex = 0.8, col = "gray50")

# Population trajectories over time
trajectory_pristine <- population_size(sim_pristine)
trajectory_single <- population_size(sim_single_large)
trajectory_several <- population_size(sim_several_small)

plot(trajectory_pristine$time, trajectory_pristine$population_size,
     type = "l", col = "darkgreen", lwd = 2,
     main = "Population Dynamics",
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max(trajectory_pristine$population_size) * 1.05))
lines(trajectory_single$time, trajectory_single$population_size,
      col = "steelblue", lwd = 2)
lines(trajectory_several$time, trajectory_several$population_size,
      col = "coral", lwd = 2)
legend("topright", legend = names(final_pops),
       col = c("darkgreen", "steelblue", "coral"), lwd = 2, bty = "n")

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Summary

The pristine landscape supports `r final_pops["Pristine"]` individuals
at simulation end. Reducing habitat to 20% yields
`r final_pops["Single_Large"]` individuals in the single large
configuration versus `r final_pops["Several_Small"]` individuals in the
several small configuration. Thus, spatial configuration accounts for a
`r abs(final_pops["Single_Large"] - final_pops["Several_Small"])`-individual
difference despite identical total habitat area (both 20%), illustrating
how spatial arrangement affects population outcomes independently of
habitat amount—a key finding in landscape ecology [@Fahrig2003].
`r if(final_pops["Several_Small"] == 0) "The fragmented configuration experienced complete collapse, demonstrating that spatial arrangement can determine viability beyond simple area calculations."`

This example demonstrates TWoLife's basic workflow: landscape creation
through fractal generation, parameter configuration using list
structures, simulation execution through the main function, and result
extraction from the output object. The discrete landscape example
introduced the function structure and basic operations without the added
complexity of continuous environmental variation and genetic diversity.
We now turn to the package's primary innovation: modeling individual
genetic variation in continuous environmental gradients, where fitness
emerges from trait-environment matching rather than binary habitat
classification.

------------------------------------------------------------------------

# Main Analysis: Individual Variation in Heterogeneous Environments

## Background and Motivation

Real environments exhibit continuous variation rather than simple binary
classifications. Temperature gradients span mountain slopes, moisture
clines traverse rainfall gradients, resource density surfaces reflect
topography and soil chemistry [@Turner1989; @Wiens1976]. Similarly, real
populations contain genetically variable individuals with different
optimal conditions and tolerance ranges, as documented extensively in
natural systems [@Bolnick2003; @Lynch1998]. Traditional models simplify
both dimensions: discrete habitat models cannot represent gradual
environmental transitions, while models assuming genetic uniformity
cannot investigate how diversity affects population outcomes.

TWoLife explicitly models both continuous environmental gradients and
individual genetic variation, thus enabling investigation of questions
that are challenging for traditional approaches:

-   **How much genetic variation is necessary** for persistence in
    heterogeneous landscapes? Can populations survive with genetic
    diversity in optimal values alone, or must tolerance ranges also
    vary among individuals?
-   **Is diversity in optimal values sufficient**, or must individuals
    also possess broad tolerance (niche width) enabling survival across
    environmental conditions? Does tolerance matter more than diversity
    in determining which individuals survive?
-   **What roles do evolution and behavior play** relative to standing
    genetic variation already present in populations? Do these dynamic
    mechanisms provide substantial additional benefits beyond initial
    diversity, or are their effects marginal?
-   **How do mechanisms interact**—additively (each adds independent
    benefit) or synergistically (combined effects exceed simple
    addition)? Understanding interaction patterns helps predict which
    mechanisms are most critical under different conditions.

We address these questions through progressive addition of genetic and
behavioral mechanisms across five scenarios. Each scenario differs only
in genetic parameters while holding all other conditions constant
(landscape, initial population size, simulation duration, master seeds).
As a consequence, any differences in population outcomes can be
attributed to the specific mechanisms that differ between scenarios,
allowing us to isolate each mechanism's contribution to persistence.

## Generating Continuous Landscapes

Setting `habitat_proportion = NULL` instructs
`create_fractal_landscape()` to generate continuous environmental values
rather than binary habitat-matrix classification. The function produces
values ranging from `min_value` to `max_value` (here, 0.0 to 1.0) with
spatial structure controlled by `fractality` as described earlier. Thus,
rather than categorizing cells as habitat or matrix, the function
assigns each cell a continuous environmental value representing local
conditions.

We generate a continuous landscape for our main analysis:

```{r continuous-landscape}
set.seed(200)
continuous_landscape <- create_fractal_landscape(
  cells_per_row = 15,
  fractality = 0.5,              # Balanced spatial autocorrelation
  habitat_proportion = NULL,      # NULL = continuous values (not binary 0/1)
  min_value = 0.0,               # Minimum environmental value
  max_value = 1.0                # Maximum environmental value
)
```

The resulting landscape contains 225 cells (15×15) with environmental
values ranging continuously from 0.0 to 1.0. These values represent
environmental conditions (temperature, moisture, resource availability,
or any relevant gradient) but carry no inherent "quality." A value of
0.3 is not intrinsically better or worse than 0.7—fitness depends on
phenotype-environment matching. An individual with genotype_mean=0.3
performs best at 0.3, while an individual with genotype_mean=0.7
performs best at 0.7. This represents a fundamental conceptual shift
from habitat-matrix models, where habitat cells (value=1) are
universally "good" and matrix cells (value=0) are universally "bad" for
all individuals equally.

```{r visualize-continuous, fig.width=5, fig.height=4.5, echo=FALSE}
plot_landscape(continuous_landscape,
                            main = "Continuous Environmental Landscape\n(fractality = 0.5)",
                            colors = "terrain")
```

The visualization uses a terrain color scheme where cooler colors
(blues, greens) represent low environmental values and warmer colors
(yellows, reds) represent high values. Observe the intermediate-scale
patchiness created by fractality=0.5—some clustering of similar values
occurs (e.g., contiguous blue regions in lower-left, yellow regions in
upper-right), but substantial variation exists throughout the landscape.
This heterogeneity creates spatial structure without the abrupt
habitat-matrix boundaries of discrete landscapes.

This phenotype-environment matching framework distinguishes TWoLife from
models that pre-assign habitat quality based solely on location type.
Here, fitness emerges dynamically from the interaction between
individual-specific traits and local conditions. As a consequence, the
package allows investigation of adaptive matching, local adaptation
trajectories, and niche evolution without assuming fitness landscapes a
priori—the fitness landscape emerges from genetic variation and
environmental structure rather than being imposed by the modeler
[@Levins1968].

## Experimental Design: Progressive Mechanisms

We implement five scenarios that differ only in genetic parameters, with
all other conditions held constant. This factorial design allows us to
isolate each mechanism's contribution to population outcomes. The order
of mechanism addition follows a biological hierarchy from fundamental to
facultative: (1) genetic diversity in optimal values is the most basic
requirement—populations need variation to span environmental gradients;
(2) tolerance (niche width) enables each genotype to survive across a
range of conditions rather than requiring exact matches; (3) evolution
(mutation + plasticity) allows populations to generate new variation and
fine-tune existing variation through natural selection; (4) behavior
(habitat selection) enables individuals to actively locate suitable
microhabitats rather than dispersing randomly. This progression tests
whether "higher" mechanisms compensate for lacking "lower" ones
(suggesting functional redundancy) or whether mechanisms are obligately
sequential (suggesting hierarchical requirements for persistence):

| Scenario | Genetic Diversity | Niche Width | Evolution | Behavior | Configuration |
|------------|------------|------------|------------|------------|------------|
| 1\. Uniform specialists | No (all genotype=1.0) | No (sds=0) | No | No | Default parameters |
| 2\. Variable specialists | Yes (genotypes 0.3-0.7) | No (sds=0) | No | No | genotype_means only |
| 3\. Generalists | Yes | **Yes (sds=0.15)** | No | No | Add genotype_sds |
| 4\. Evolution | Yes | Yes | **Yes** (mutation + plasticity) | No | Add mutation, plasticity |
| 5\. Habitat selection | Yes | Yes | Yes | **Yes** (sampling=100) | Add sampling_points |

All scenarios use identical conditions except genetic parameters: - Same
landscape (continuous_landscape generated above with the same spatial
structure) - Same initial population size (40 individuals, representing
a moderate starting population) - Same simulation duration (250
demographic events, sufficient to observe dynamics without excessive
computation) - Different but comparable master seeds (45-49, ensuring
independent realizations while maintaining similar stochastic
properties)

The progressive design means each scenario builds on the previous one by
adding a single mechanism. As a consequence, we can attribute population
changes to specific mechanisms and test whether mechanisms interact
additively (each adds independent benefit) or synergistically (combined
effects exceed simple addition). This design also reveals whether
mechanisms show diminishing returns (later additions provide smaller
benefits) or accelerating returns (later additions provide larger
benefits, possibly through synergistic interactions).

Before running scenarios, we pre-generate genotype_mean values for
Scenarios 2-5 to ensure comparability. Using the same genotype
distribution across scenarios isolates the effects of tolerance,
evolution, and behavior without confounding by different starting
genetic compositions:

```{r pre-generate-genotypes}
# Pre-generate genotypes for Scenarios 2-5
# Uniform distribution from 0.3 to 0.7 captures most environmental range
set.seed(300)
initial_genotypes <- runif(40, 0.3, 0.7)
```

## Scenario 1: Uniform Perfect Specialists

This example demonstrates default behavior when `genetic_params` is
omitted. All individuals have identical genotype_mean=1.0 and
genotype_sd=0 (zero tolerance). Thus, the population is genetically
uniform and individuals are perfect specialists requiring exact
environmental matches.

```{r scenario1}
sim_s1 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  # Omit genetic_params to use defaults: all genotype=1.0, sd=0
  simulation_params = list(max_events = 250),
  master_seed = 45
)

(pop_s1 <- sim_s1$summary$final_population_size)
```

The simulation results in N = `r pop_s1` (extinction). This outcome
occurs because zero tolerance (genotype_sd=0) means individuals require
exact environmental matches that don't exist in the continuous landscape
(range: `r sprintf("%.2f", min(continuous_landscape))` to
`r sprintf("%.2f", max(continuous_landscape))`). With genotype_sd=0, even
small mismatches produce near-zero fitness. This demonstrates that
genetic uniformity combined with specialist strategies is incompatible
with persistence in heterogeneous continuous environments.

## Scenario 2: Variable Specialists

This example demonstrates genetic diversity in optimal values
(genotype_mean) without tolerance. Each of 40 individuals has a
different genotype_mean sampled uniformly from 0.3 to 0.7, but
genotype_sd remains at 0 (perfect specialists). Thus, the population
contains genetic diversity spanning the environmental range, but
individuals still require exact matches.

```{r scenario2}
sim_s2 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes  # 40 different optimum values 0.3-0.7
    # genotype_sds defaults to 0 when not specified
  ),
  simulation_params = list(max_events = 250),
  master_seed = 46
)

(pop_s2 <- sim_s2$summary$final_population_size)
```

The simulation results in N = `r pop_s2` (extinction). Despite having 40
different genotypes spanning the environmental range (0.3-0.7), zero
tolerance means individuals still require exact environmental matches.
In continuous space, exact matches rarely occur—even if an individual
has genotype_mean=0.5 and a cell has environment=0.5, plasticity noise
(absent here with plasticity=0) or slight mismatches produce effectively
zero fitness when genotype_sd=0. This demonstrates that genetic
diversity alone is insufficient without tolerance enabling survival
across a range of conditions.

## Scenario 3: Generalists (Niche Width)

This example demonstrates the effect of adding tolerance (genotype_sd).
Each individual has the same genotype_mean as Scenario 2 (maintaining
identical genetic diversity), but now with genotype_sd=0.15, enabling
survival across a range of conditions around their optima.

```{r scenario3}
sim_s3 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,      # Same genetic diversity as S2
    genotype_sds = rep(0.15, 40)            # Add tolerance: key difference from S2
  ),
  simulation_params = list(max_events = 250),
  master_seed = 47
)

(pop_s3 <- sim_s3$summary$final_population_size)
```

The simulation results in N = `r pop_s3`
(`r sprintf("%.1f%%", pop_s3/40*100)` survival), compared to N=0 in
Scenarios 1-2. Adding tolerance enables population persistence by
allowing individuals to survive in cells where their phenotype does not
exactly match the local environment. With genotype_sd=0.15, individuals
retain substantial fitness (\>0.5) within approximately ±0.15 of their
optimum, and non-zero fitness extends further. This tolerance interacts
with genetic diversity: because different individuals have different
optima (genotype_means from 0.3 to 0.7), collectively they can utilize
most of the environmental gradient. However, individuals still disperse
randomly (sampling_points=1) and genetic composition cannot change over
time (mutation_rate=0).

Survivor genotype distribution reveals which individuals persisted:

```{r scenario3-analysis}
# Examine survivor trait distribution
if (pop_s3 > 0) {
  survivor_summary <- c(
    Mean_genotype = mean(sim_s3$survivors$genotype),
    SD_genotype = sd(sim_s3$survivors$genotype),
    Range = paste0("[", sprintf("%.2f", min(sim_s3$survivors$genotype)),
                   ", ", sprintf("%.2f", max(sim_s3$survivors$genotype)), "]")
  )
  survivor_summary
}
```

## Scenario 4: Evolution (Mutation + Plasticity)

This example demonstrates adding evolutionary mechanisms (mutation and
plasticity) to the diversity and tolerance from Scenario 3. Mutation
(mutation_rate=0.05) enables heritable genetic change across
generations, while plasticity (plasticity=0.02) enables non-heritable
phenotypic variation within lifetimes.

```{r scenario4}
sim_s4 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),   # Enable evolution across generations
    plasticities = rep(0.02, 40)      # Enable phenotypic variation
  ),
  simulation_params = list(max_events = 250),
  master_seed = 48
)

(pop_s4 <- sim_s4$summary$final_population_size)
(delta_evolution <- pop_s4 - pop_s3)
```

The simulation results in N = `r pop_s4` (change:
`r sprintf("%+d", delta_evolution)` from Scenario 3). Evolution provides
`r ifelse(delta_evolution > 0, "additional benefit", ifelse(delta_evolution < 0, "reduced performance", "no net effect"))`
beyond static genetic diversity and tolerance. Mutation allows the
population to explore genetic space beyond the initial genotype
distribution (0.3-0.7), potentially adapting to local environmental
conditions if selection favors particular genotypes. Plasticity allows
phenotypes to deviate from genotypes, which can be beneficial if it
increases variance in trait-environment matching, though it can also be
detrimental if it moves phenotypes away from local optima. The net
effect depends on the balance between these processes over the
simulation duration.

## Scenario 5: Habitat Selection (Behavioral Optimization)

This example demonstrates adding habitat selection behavior
(sampling_points=100) to all mechanisms from Scenario 4. Individuals
evaluate 100 potential dispersal locations and preferentially select
high-fitness sites through softmax weighting, representing sophisticated
habitat assessment.

```{r scenario5}
sim_s5 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),
    plasticities = rep(0.02, 40),
    sampling_points = rep(100, 40)  # Enable habitat selection
  ),
  simulation_params = list(max_events = 250),
  master_seed = 49
)

(pop_s5 <- sim_s5$summary$final_population_size)
(delta_behavior <- pop_s5 - pop_s4)
(cumulative_gain <- pop_s5 - pop_s2)
```

The simulation results in N = `r pop_s5` (change:
`r sprintf("%+d", delta_behavior)` from Scenario 4). Habitat selection
provides
`r ifelse(delta_behavior > 0, "additional benefit", ifelse(delta_behavior < 0, "reduced performance", "no net effect"))`
beyond evolution and tolerance. Cumulative gain from Scenario 2 (extinct
baseline with diversity but no tolerance): `r cumulative_gain`
individuals. This cumulative perspective reveals that tolerance
(Scenario 3) was the critical transition enabling persistence, while
evolution and behavior provided
`r ifelse(cumulative_gain - pop_s3 > 0, "additional incremental benefits", "marginal effects")`.

## Comparative Analysis

The table below summarizes population outcomes across all five
scenarios. The "Change" column shows each mechanism's incremental
contribution, revealing relative importance and potential interaction
effects:

```{r comparative-summary}
# Summary table showing progressive mechanism effects
results_summary <- data.frame(
  Scenario = c("S1: Uniform", "S2: Diversity", "S3: Tolerance",
               "S4: Evolution", "S5: Behavior"),
  Final_N = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
  Change = c("—",
             sprintf("%+d", pop_s2 - pop_s1),
             sprintf("%+d", pop_s3 - pop_s2),
             sprintf("%+d", pop_s4 - pop_s3),
             sprintf("%+d", pop_s5 - pop_s4)),
  Mechanism_Added = c("None (baseline)",
                      "Genetic diversity in optima",
                      "Tolerance (niche width)",
                      "Mutation + plasticity",
                      "Habitat selection")
)
results_summary
```

The figure below shows population trajectories over time (left panel)
and final population sizes (right panel) across scenarios. Note that
Scenarios 1-2 (red bars, extinct) differ fundamentally from Scenarios
3-5 (green bars, viable), suggesting tolerance is a critical threshold
parameter. The trajectory panel reveals temporal dynamics: Scenario 3
shows initial decline then stabilization (demographic adjustment to
carrying capacity), while Scenarios 4-5 show
`r ifelse(pop_s4 > pop_s3 | pop_s5 > pop_s4, "enhanced dynamics", "similar patterns")`
from evolutionary and behavioral mechanisms. All scenarios started with
N=40 (black horizontal line in left panel):

```{r comparative-visualization, fig.width=9, fig.height=4.5, echo=FALSE}
par(mfrow = c(1, 2), mar = c(5, 4, 3, 2))

# Extract population trajectories for viable scenarios
traj_s3 <- population_size(sim_s3)
traj_s4 <- population_size(sim_s4)
traj_s5 <- population_size(sim_s5)

# Population dynamics over time (only viable scenarios shown)
max_pop <- max(c(traj_s3$population_size, traj_s4$population_size, traj_s5$population_size))
plot(traj_s3$time, traj_s3$population_size, type = "l", col = "blue", lwd = 2,
     main = "Population Trajectories\n(Viable Scenarios Only)",
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max_pop * 1.05))
lines(traj_s4$time, traj_s4$population_size, col = "darkgreen", lwd = 2)
lines(traj_s5$time, traj_s5$population_size, col = "purple", lwd = 2)
abline(h = 40, lty = 1, col = "black", lwd = 1.5)
text(max(traj_s3$time)*0.02, 40, "Initial N=40", pos = 3, cex = 0.9, font = 2)
legend("topright", legend = c("S3: Tolerance", "S4: Evolution", "S5: Behavior"),
       col = c("blue", "darkgreen", "purple"), lwd = 2, bty = "n", cex = 0.85)

# Final population sizes (all scenarios) with clearer color scheme
barplot(c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
        names.arg = c("S1", "S2", "S3", "S4", "S5"),
        main = "Final Population Sizes\n(Red=Extinct, Green=Viable)",
        ylab = "Population Size (N)",
        col = c("red", "red", "lightgreen", "green", "darkgreen"),
        las = 1)
text(x = seq(0.7, by = 1.2, length.out = 5),
     y = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5) + max(c(1, pop_s3, pop_s4, pop_s5)) * 0.05,
     labels = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
     cex = 1.1, font = 2)
abline(h = 0, lwd = 0.5)

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Verifying Phenotype-Environment Matching

The `check_habitat_match()` function visualizes phenotype-environment
matching by comparing survivor trait values with their occupied
locations. It produces two side-by-side panels: (left) the landscape
showing environmental values as a colored gradient, and (right) survivor
positions as colored dots where each dot's color represents its
phenotype (or genotype) value. Both panels share the same color scale,
so effective habitat matching appears as dot colors matching the
background landscape colors—for example, individuals with low phenotypes
(cool colors: blues, greens) occupying low-value regions (also
blue/green background), and individuals with high phenotypes (warm
colors: yellows, reds) occupying high-value regions (also yellow/red
background).

**Interpreting matching quality**: Strong phenotype-environment matching
is indicated when dot colors in the right panel match their underlying
background colors from the left panel—visually, this appears as colored
dots "blending in" with the landscape gradient. Poor matching appears as
color mismatches, such as blue dots (low phenotypes) sitting on
yellow/red backgrounds (high environmental values), or red dots (high
phenotypes) sitting on blue backgrounds (low environmental values).

**Scenario 3 (Tolerance only):** We expect moderate
phenotype-environment matching from passive processes. Without evolution
or active habitat selection, matching occurs only through differential
survival—individuals with poor phenotype-environment matches die,
leaving survivors in locations where their traits happen to fit well.
This passive filtering should produce some spatial structure but not the
strong segregation possible with active habitat selection.

```{r validation-s3, fig.width=8, fig.height=4}
if (pop_s3 > 0) {
  check_habitat_match(sim_s3,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

The plots show the landscape environmental gradient (left) and survivor
locations colored by their phenotypes (right). When dot colors match the
background colors of the landscape, this indicates good
phenotype-environment matching. Individuals with low phenotypes (cool
colors: blues, greens) tend to occupy low-value regions (also shown in
cool colors on the landscape), while high phenotypes (warm colors:
yellows, reds) occupy high-value regions (also warm colors). This
suggests differential survival has filtered the population such that
remaining individuals match their local environments reasonably well,
even without active habitat selection.

**Scenario 4 (Evolution added):** We expect similar or slightly improved
matching compared to Scenario 3. Evolution through mutation enables
gradual genetic shifts toward better local adaptation, but the process
is slow relative to the simulation duration (250 events may not provide
sufficient generations for substantial evolutionary change). The primary
matching mechanism remains differential survival from tolerance
(genotype_sd=0.15), though evolution may fine-tune genotype
distributions toward locally abundant environmental values.

```{r validation-s4, fig.width=8, fig.height=4}
if (pop_s4 > 0) {
  check_habitat_match(sim_s4,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

The plots should show similar spatial patterns to Scenario 3, with
survivor dots (right panel) matching the colors of their underlying
landscape locations (left panel). Good matching appears as dots
"blending in" with the background gradient—blue dots on blue regions,
yellow/red dots on yellow/red regions. Any improvement in color matching
over Scenario 3 would suggest evolution has shifted genotype
distributions toward locally favored values, though the short simulation
duration may limit such effects.

**Scenario 5 (Habitat selection added):** We expect the strongest
phenotype-environment matching due to active spatial optimization. With
sampling_points=100, dispersing individuals evaluate many potential
locations and preferentially select sites where their phenotype matches
the local environment. This behavioral mechanism produces clear spatial
segregation: low-phenotype individuals concentrate in low-value regions
(blue areas of the landscape), high-phenotype individuals in high-value
regions (yellow-red areas). This active matching should exceed the
passive filtering of Scenarios 3-4.

```{r validation-s5, fig.width=8, fig.height=4}
if (pop_s5 > 0) {
  check_habitat_match(sim_s5,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

The plots should show the strongest phenotype-environment matching with
clear spatial segregation visible as strong color alignment between the
two panels. Low-phenotype individuals (blue dots in right panel) should
concentrate in low-value regions (blue areas in left panel), while
high-phenotype individuals (yellow/red dots) concentrate in high-value
regions (yellow/red areas). This strong color matching—where dots
visually "disappear" into the background gradient—indicates individuals
successfully located suitable microhabitats through active habitat
selection.

# Computational Considerations

## Performance Scaling

TWoLife's computational cost is dominated by neighbor calculations that occur
during each demographic event (birth, death, dispersal). Understanding these
scaling relationships helps in designing feasible simulation experiments:

-   **Population size**: Cost scales **quadratically** (O(N²)) with population
    size because each event requires updating neighbor lists (O(N) operation),
    and larger populations generate proportionally more events. Doubling
    population size increases runtime approximately 4-fold.

-   **Landscape size**: Indirectly affects cost through carrying capacity.
    Larger landscapes support proportionally more individuals at equilibrium
    (density = N/area). Doubling landscape dimensions increases area 4-fold,
    supporting ~4× more individuals, which increases cost ~16-fold due to O(N²)
    scaling.

-   **Habitat selection**: Cost scales linearly with `sampling_points`. Use
    sampling_points=1 for exploration, 10-100 when habitat selection mechanisms
    are scientifically important.

-   **Simulation duration**: Cost scales linearly with `max_events`.

**Recommendation:** Start with smaller simulations (15-30 cell landscapes, N =
40-100, sampling_points = 1) for parameter exploration. Scale up cautiously,
recognizing that doubling landscape dimensions costs ~16× more computation.

## Memory Usage

Memory usage scales linearly with simulation duration because TWoLife stores
complete event histories. Each event requires approximately 200-500 bytes
depending on genetic architecture, so a simulation with 10,000 events requires
roughly 2-5 MB. Memory is not a limiting factor for most applications, but for
extremely long simulations (>1 million events), monitor memory usage.

## Reproducibility

Simulations are exactly reproducible if three conditions are met:

1.  **Same master_seed**: The `master_seed` parameter controls all
    stochasticity
2.  **Same TWoLife version**: Algorithm implementations may change between
    versions
3.  **Same R version**: Underlying random number generators may differ across R
    versions

The `master_seed` ensures that identical parameter sets produce identical
results, enabling rigorous hypothesis testing and debugging.

## Parallelization

For parameter sweeps or Monte Carlo replication, simulations can be
parallelized using R's parallel processing capabilities. Each simulation
is independent (given different seeds), enabling perfect parallelization
with linear speedup up to the number of available cores:

```{r parallelization-example, eval=FALSE}
library(parallel)

# Detect available cores (leave 1 for system responsiveness)
n_cores <- detectCores() - 1

# Example: replicate Scenario 3 (tolerance) 100 times with different seeds
# to estimate distribution of population outcomes under fixed conditions
n_reps <- 100
results <- mclapply(1:n_reps, function(i) {
  twolife_simulation(
    landscape_params = list(habitat = continuous_landscape),
    individual_params = list(initial_population_size = 40),
    genetic_params = list(
      genotype_means = runif(40, 0.3, 0.7),  # New random genotypes each rep
      genotype_sds = rep(0.15, 40)
    ),
    simulation_params = list(max_events = 250),
    master_seed = 1000 + i  # Different seed per replicate
  )
}, mc.cores = n_cores)

# Extract and analyze distribution of outcomes
final_sizes <- sapply(results, function(x) x$summary$final_population_size)
hist(final_sizes, breaks = 20, col = "lightblue", border = "white",
     main = "Distribution of Final Population Sizes\n(100 Replicates)",
     xlab = "Final N")
abline(v = mean(final_sizes), col = "red", lwd = 2, lty = 2)
text(mean(final_sizes), par("usr")[4]*0.9,
     paste0("Mean = ", round(mean(final_sizes), 1)), pos = 4, col = "red")
```

# References

::: {#refs}
:::
