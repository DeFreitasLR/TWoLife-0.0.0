---
title: "TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes"
author: "Lucas Freitas"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
bibliography: references.bib
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  cache = FALSE
)
```

# Introduction

The **TWoLife** package implements individual-based simulations of
populations inhabiting spatially heterogeneous landscapes. Unlike
traditional models that assume genetic uniformity within populations,
TWoLife explicitly represents individual variation in traits that
determine ecological outcomes. As a consequence, the package allows
researchers to investigate how preexisting genetic diversity interacts
with landscape structure to influence population persistence
[@Bolnick2003; @Barrett2008].

The package addresses a fundamental limitation of ecological theory: the
assumption that individuals within a population perceive and exploit
environments in identical ways. This assumption, while simplifying
mathematical analysis, may not depict biologically realistic scenarios
[@Bolnick2011]. In reality, individuals differ in their
optimal environmental conditions, tolerance ranges, and behavioral
strategies. This in turn means that environmental changes may favor some
individuals to the detriment of others, with consequences for
population-level outcomes that cannot be predicted from species-level
averages alone [@Violle2012].

TWoLife enables researchers to:

1.  Generate landscapes with **continuous environmental gradients**
    representing variation in conditions across space, or **discrete
    habitat patches** embedded in unsuitable matrix
2.  Model **individual genetic variation** in optimal environmental
    values, tolerance ranges (niche width), and behavioral strategies
3.  Implement **evolutionary and adaptive mechanisms** including
    mutation (heritable genetic changes), phenotypic plasticity
    (non-heritable developmental noise), and natural selection
4.  Track **phenotype-environment interactions** where fitness emerges
    dynamically from the match between individual traits and local
    conditions, rather than being pre-assigned by habitat type
5.  Analyze **emergent population dynamics** arising from
    individual-level processes of birth, death, dispersal, and trait
    evolution

This vignette first introduces the package’s key concepts, function
structure, and output format, then demonstrates TWoLife’s core
capability through a worked analysis: modeling populations where fitness
emerges dynamically from phenotype–environment matching along continuous
gradients. Through a progressive five-scenario comparison, we isolate
the contributions of genetic diversity, tolerance, evolutionary
processes, and habitat selection behavior to population persistence.
This design directly addresses a question that habitat-quality models
cannot: which individual-level mechanisms are necessary for populations
to persist across heterogeneous environments?

# Key Concepts

## Landscapes

Spatial environments in TWoLife are represented as rectangular numeric
matrices where each cell contains an environmental value. The package
supports two fundamentally different landscape types that determine how
environmental variation structures individual fitness:

-   **Continuous landscapes**: Environmental values vary along
    gradients, typically rescaled to a user-defined range (e.g., 0.0 to
    100.0 as used throughout this vignette). These values represent
    continuous variation in conditions such as temperature, soil
    moisture, or resource availability. In continuous landscapes, no
    locations are inherently unsuitable. Rather, suitability emerges
    dynamically from the interaction between individual phenotypes and
    local environmental values through Gaussian matching (explained in
    the Fitness section below). This means that a cell with value 3 is
    not intrinsically "better" or "worse" than a cell with value 10 —
    suitability depends on whether individuals in the population possess
    phenotypes adapted to those particular values.

-   **Discrete landscapes**: Space is divided into binary categories
    where cells are classified as either suitable habitat (value=1) or
    unsuitable matrix (value=0). Individuals can persist only in habitat
    cells; matrix cells are immediately lethal regardless of individual
    traits. This paradigm corresponds to traditional patch-matrix
    landscape ecology [@Fahrig2003].

Landscapes are generated using `create_fractal_landscape()`, which
produces realistic spatial patterns with self-similar structure across
scales [@Justeau-Allaire2022]. The fractal algorithm ensures that
pattern complexity — the degree of patchiness versus smoothness —
remains similar whether the landscape is viewed at fine resolution
(individual cells) or coarse resolution (blocks of cells). This property
mimics natural spatial processes where environmental structure often
exhibits scale-invariant patterns [@Milne1992; @Wiens1976].

## Individuals

Individuals are characterized by five genetic attributes that together
determine ecological and evolutionary outcomes:

-   **`genotype_mean`** (Optimal environmental value): The environmental
    condition at which the individual achieves maximum fitness,
    representing the genetically-determined optimal niche position.
    Values ideally match in the landscape's environmental scale. For
    example, an individual with genotype_mean=0.3 is genetically adapted
    to environmental value 0.3 (e.g., cool temperatures if the gradient
    represents temperature). When an individual's phenotype
    (genotype_mean plus noise from plasticity) exactly matches the local
    environmental value, fitness equals to its maximum.

-   **`genotype_sd`** (Niche width/tolerance): The breadth of
    environmental conditions the individual can tolerate, represented
    mathematically as the standard deviation ($\sigma$) in the Gaussian
    fitness function. This parameter governs the specialist-generalist
    tradeoff: values near $\sigma_{min}$ (e.g., genotype_sd=0.4) yield
    near-maximum peak fitness with a very steep fitness decline away
    from the optimum — on a 0–100 landscape this niche width covers only
    $\approx 0.4$% of the environmental range, representing a true
    narrow specialist. Larger values (e.g., genotype_sd=5.0) produce
    broader tolerance but lower peak fitness, illustrating the “jack of
    all trades, master of none” pattern [@Levins1968; @Futuyma1988].

-   **`mutation_rate`** (Mutation rate): Controls heritable genetic
    variation transmitted across generations. This parameter determines
    the standard deviation (μ_r) of mutations added to the offspring's
    genotype at each birth event. Unlike plasticity, which affects
    phenotype but not inheritance, mutations modify the genotype itself
    and these modifications are passed to future generations. This
    enables evolutionary adaptation—populations can shift their genetic
    composition in response to selection pressures [@Lynch1998]. The underlying
    mathematical model is:

    $g_{\text{offspring}} = g_{\text{parent}} +
    \varepsilon_{\text{mutation}}$

    where $\varepsilon_{\text{mutation}}
    \sim N(0, \mu_r)$ and $\mu_r$ = mutation_rate parameter.

-   **`plasticity`** (Phenotypic plasticity): Controls non-heritable
    phenotypic variation arising from developmental or environmental
    noise. This parameter determines the standard deviation (ψ) of
    random variation added to an individual's genotype at birth to
    produce its phenotype, which then remains fixed for the individual's
    lifetime. Importantly, the phenotype (not genotype) determines
    fitness and habitat selection, while only the genotype is
    transmitted to offspring. This distinction allows modeling of
    developmental variation that affects individual ecology but is not
    inherited [@Pigliucci2001; @DeWitt2004]. Mathematically, the relationship can be expressed as:

    $p = g + \varepsilon_{\text{plasticity}}$

    where $\varepsilon_{\text{plasticity}} \sim N(0, \psi)$ and $\psi$ =
    plasticity parameter (same principle as mutation).

-   **`sampling_points`** (Habitat selection intensity): The number of
    potential dispersal locations an individual evaluates before
    deciding where to move. When sampling_points is set to 0 or 1,
    individuals move to randomly chosen locations without evaluation,
    representing passive dispersal mechanisms. These two values are
    conceptually equivalent in producing passive dispersal but differ in
    implementation—0 triggers a random walk algorithm while 1 samples a
    single random location. As sampling_points increases, individuals
    gain the capacity to assess and compare multiple locations before
    settling, selecting among them using a softmax function weighted by
    expected fitness. Unlike the ideal free distribution [@Fretwell1970],
    which assumes perfect information, the softmax implements
    probabilistic choice under limited sampling — a bounded-rationality
    decision rule in which the temperature parameter controls the
    sharpness of preference [@McNamara1987]. Higher values enable
    increasingly sophisticated habitat selection and increase computation
    time linearly, but the softmax process retains some randomness to
    prevent unrealistic determinism where all individuals always select
    the single best available cell.

All five attributes are heritable, enabling evolutionary dynamics and
potential local adaptation over multiple generations [@Kawecki2004]. Fitness emerges
from the interaction between these traits and local conditions, as
defined in the Fitness section below.

## Fitness: How Traits Determine Survival

Survival-related processes in TWoLife are determined by Gaussian
matching—a mathematical function that quantifies how well an
individual's phenotype matches local environmental conditions. This
fitness framework differs fundamentally from models where habitat
quality is pre-assigned by location type (e.g., habitat cells support
survival, matrix cells do not). Instead, fitness emerges dynamically
from trait-environment interactions:

$$W = \frac{1}{\sigma\sqrt{2\pi}} \exp\left(-\frac{(h - p)^2}{2\sigma^2}\right)$$

where:

-   $W$ is the individual's fitness (a probability density value)
-   $p$ (phenotype) is the individual's expressed trait value
    (genotype_mean plus developmental noise from the plasticity
    parameter, sampled once at birth; see Individuals section above)
-   $h$ (environment) is the environmental value at the cell where the
    individual currently resides (ranging from 0 to 100 in the
    continuous landscape used throughout this vignette, though any
    numeric range is valid; or 0/1 in binary landscapes)
-   $\sigma$ (genotype_sd) is the individual's tolerance parameter
    (niche width; see Individuals section above)

This function uses the **probability density form** of the Gaussian,
which introduces a critical tradeoff. At a perfect phenotype-environment
match ($h = p$), fitness equals $1/(\sigma\sqrt{2\pi})$. Peak fitness
therefore *declines* as $\sigma$ increases. The constraint

$\sigma \geq \sigma_{min} =
1/\sqrt{2\pi} \approx 0.3989$

prevents fitness from exceeding 1.0: at $\sigma = \sigma_{min}$, peak
fitness equals exactly 1.0; for all larger $\sigma$, peak fitness falls
below 1.0.

This creates an explicit **specialist-generalist tradeoff**: narrow
niche width (small $\sigma$, near $\sigma_{min}$) yields near-maximum
peak fitness but steep fitness decline away from the optimum, while
broad niche width (large $\sigma$) yields moderate fitness across a wide
range of conditions but never achieves peak performance — the "jack of
all trades, master of none" pattern [@Levins1968]. Note that
$\sigma = 0$ is a separate special case handled by discrete logic
(perfect specialists; see below), so valid values for Gaussian fitness
individuals are either exactly 0 or at least $\approx 0.3989$.

Rather than acting directly as a survival probability, fitness $W$ in
TWoLife modulates mortality rate. Mortality is bounded between a minimum
rate in optimal habitat ($\mu_{min}$ = base_mortality_rate) and a
maximum rate in highly unsuitable habitat ($\mu_{max}$ =
base_mortality_rate $\times$ matrix_mortality_multiplier). Fitness
determines where within this range an individual’s mortality falls:

$$
\mu = \mu_{max} - W\left(\mu_{max} - \mu_{min}\right)
$$

Under this formulation, individuals with fitness near 1.0 experience
near-minimum mortality, while individuals with very low fitness approach
maximum mortality. Because the PDF fitness formulation means peak
$W < 1$ for most $\sigma$ values, even well-matched individuals
experience mortality slightly above $\mu_{min}$; only individuals with
$\sigma =
\sigma_{min}$ achieve $\mu_{min}$ in perfect habitat. This smoothly
implements stabilizing selection through environment-dependent survival
[@Lande1976] while keeping mortality rates biologically interpretable
and bounded.

The figure below makes this tradeoff concrete using the parameter values
from the Main Analysis: `base_mortality_rate = 0.2` ($\mu_{min}$) and
`matrix_mortality_multiplier = 2.0`, which together give
$\mu_{max} = 0.2 \times 2.0 = 0.4$. The display window spans $h \in
[0, 10]$ with the individual's phenotype at $p = 5.0$ (midpoint). Four
$\sigma$ values are shown: the critical threshold $\sigma_{min}$;
$\sigma = 0.5$; $\sigma = 0.8$; and $\sigma = 1.0$. All four values are
deliberately close together to highlight how even small increases in
niche width carry a measurable mortality cost at the optimum. Filled
circles mark each curve's lowest point ($h = p = 5.0$); colored tick
marks on the right axis give the exact $\mu_{opt}$ for each curve:

```{r mortality-curve, fig.width=7, fig.height=5, echo=FALSE}
# Parameters matching Scenarios 3-5 in the Main Analysis
mu_min    <- 0.2               # base_mortality_rate
mu_max    <- 0.2 * 2.0         # base_mortality_rate × matrix_mortality_multiplier = 0.4
sigma_min <- 1 / sqrt(2 * pi)  # critical threshold ≈ 0.3989

# Full landscape range used for computing curves; xlim clips the display to [0, 10]
h       <- seq(0, 100, length.out = 600)
optimum <- 5.0   # individual's phenotype; midpoint of the [0, 10] display window

# Four sigma values close to sigma_min to show the cost of niche broadening
sigmas <- c(sigma_min, 0.5, 0.8, 1.0)
cols   <- c("#9b59b6", "#e74c3c", "#3498db", "#2ecc71")

# Mortality at each environmental value h
compute_mu <- function(s) {
  W <- (1 / (s * sqrt(2 * pi))) * exp(-0.5 * ((h - optimum) / s)^2)
  mu_max - W * (mu_max - mu_min)
}
mu_curves <- lapply(sigmas, compute_mu)

# Peak mortality at h = optimum for each sigma
mu_at_opt <- sapply(sigmas, function(s) {
  mu_max - (1 / (s * sqrt(2 * pi))) * (mu_max - mu_min)
})

# Zoom y-axis to the ecologically relevant range: [mu_min − margin, mu_max + margin]
# This expands the visible range so small differences at the optimum are readable.
ylim_lo <- mu_min - 0.04
ylim_hi <- mu_max + 0.035

par(mar = c(5, 4.5, 3.5, 4.0))
plot(h, mu_curves[[1]], type = "n",
     xlim = c(0, 10), ylim = c(ylim_lo, ylim_hi),
     xlab = expression(paste("Environmental value  ", italic(h))),
     ylab = expression(paste("Mortality rate  ", mu)),
     main = expression(paste("Mortality rate across the environmental gradient  (",
                             italic(p), " = 5.0)")),
     las = 1)

# Faint horizontal guides at each curve's peak mortality level.
# These run only across the left half (h < optimum) so they do not clutter
# the descent on the right and do not pass through the legend.
for (i in seq_along(sigmas)) {
  segments(0, mu_at_opt[i], optimum - 0.15, mu_at_opt[i],
           col = adjustcolor(cols[i], alpha.f = 0.20), lty = 1, lwd = 1.2)
}

# Dashed bounds at mu_min and mu_max; vertical guide at optimum
abline(h = mu_min,  lty = 2, col = "grey60", lwd = 1.2)
abline(h = mu_max,  lty = 2, col = "grey60", lwd = 1.2)
abline(v = optimum, lty = 3, col = "grey65", lwd = 1.2)

# Right-axis labels for the parameter bounds (grey)
mtext(expression(mu[min] == 0.2), side = 4, at = mu_min,
      las = 1, cex = 0.72, col = "grey45", line = 0.3)
mtext(expression(mu[max] == 0.4), side = 4, at = mu_max,
      las = 1, cex = 0.72, col = "grey45", line = 0.3)

# Optimum annotation above the vertical guide
text(optimum + 0.15, ylim_hi * 0.995,
     expression(paste("optimum  ", italic(p), " = 5.0")),
     adj = c(0, 1), cex = 0.75, col = "grey45")

# Draw mortality curves
for (i in seq_along(sigmas)) {
  lines(h, mu_curves[[i]], col = cols[i], lwd = 2.5)
}

# Filled circles at each curve's lowest point (h = optimum)
points(rep(optimum, length(sigmas)), mu_at_opt,
       pch = 21, bg = cols, col = "white", cex = 2.0, lwd = 1.5)

# Colored right-axis tick marks at each mu_at_opt level.
# sigma_min coincides exactly with mu_min (already labelled grey) so is skipped.
# The ticks let the reader read off exact peak-mortality values without
# placing text labels inside the figure body where curves overlap.
for (i in 2:length(sigmas)) {
  axis(4, at = mu_at_opt[i],
       labels = formatC(mu_at_opt[i], digits = 3, format = "f"),
       col.axis = cols[i], col.ticks = cols[i],
       las = 1, cex.axis = 0.70, tcl = -0.3, lwd = 0, lwd.ticks = 1)
}

# Legend in the bottom-left corner.
# At h = 0–3 all four curves are pressed against mu_max (top of the zoomed plot),
# leaving the bottom-left region completely empty — ideal for the legend.
legend("bottomleft",
       legend = c(
         expression(sigma[min] %~~% 0.3989 ~ " (critical threshold)"),
         expression(sigma == 0.5),
         expression(sigma == 0.8),
         expression(sigma == 1.0)
       ),
       col = cols, lwd = 2.5, pch = 21, pt.bg = cols,
       pt.cex = 1.6, bty = "n", cex = 0.83,
       title = expression(bold(paste("Niche width  ", sigma))))
```

Three features stand out. First, $\mu_{opt}$ increases monotonically
with $\sigma$: only $\sigma_{min}$ achieves the true minimum mortality
$\mu_{min} = 0.2$; $\sigma = 0.5$ raises $\mu_{opt}$ to $0.240$; and
$\sigma = 1.0$ raises it further to $0.320$ — still below
$\mu_{max} = 0.4$, so all strategies remain viable. Read off these
values directly from the colored right-axis ticks. Second, note that the
curves look nearly identical everywhere except very close to
$h = p = 5.0$: at $h = 3$ (two units from the optimum), all four curves
are already pressed against $\mu_{max}$, illustrating that even moderate
habitat mismatch is effectively lethal for these narrow-niche values.
The entire fitness benefit of a wider niche is compressed into a very
small window around the optimum. Third, the survival cost of generalism
is not binary — there is no threshold beyond which individuals suddenly
go extinct — but a smooth, monotonic elevation of $\mu_{opt}$ with
$\sigma$. With `matrix_mortality_multiplier = 2.0` (Scenarios 3–5), even
$\sigma = 1.0$ survives at its optimum, but pays a 60% higher mortality
rate there than $\sigma_{min}$ does ($0.320$ vs $0.200$).

# Package Overview

We begin by loading the package:

```{r load-package}
library(TWoLife)
```

## Main Function

TWoLife simulations are executed through a single main function that
accepts five components organized to separate spatial, demographic,
genetic, temporal, and stochastic aspects of the model. Demographic
events are scheduled using the Gillespie algorithm, which generates
exact stochastic trajectories from continuous-time event rates
[@Gillespie1976; @Gillespie1977]. This organization reflects the structure of individual-based models more
generally, where populations are defined by their environment
(landscape), initial configuration (individuals), heritable variation
(genetics), and temporal dynamics (simulation parameters), with
stochasticity controlled through seeding [@Grimm2005; @DeAngelis2005].

The four parameter lists are:

-   **landscape_params**: A list containing spatial environment
    configuration, specifically the habitat matrix and optionally
    environmental values
-   **individual_params**: A list containing population initialization
    settings (starting population size and positions)
-   **genetic_params**: An optional list specifying individual variation
    in genetic traits (optimal values, tolerance, mutation rates,
    plasticity, and behavior)
-   **simulation_params**: A list containing simulation control and
    stopping conditions (duration limits)

The fifth component is **master_seed**, an integer value that ensures
complete reproducibility by controlling all random processes in the
simulation, from initial individual placement to demographic event
ordering to mutation directions.

The function structure is:

```{r eval=FALSE}
twolife_simulation(
  landscape_params,
  individual_params,
  genetic_params,
  simulation_params,
  master_seed
)
```

**Important note on genetic_params**: This list is optional. When
`genetic_params` is omitted, TWoLife applies default values designed
specifically for binary landscapes where habitat=1 and matrix=0. Under
these defaults, all individuals have genotype_mean=1 (matching habitat
value), genotype_sd=0 (zero tolerance, requiring exact environmental
matches), mutation_rate=0 (no evolution), plasticity=0 (no phenotypic
noise), and sampling_points=0 (random dispersal). These defaults work
well for exploring habitat-matrix simulations without genetic
complications, as they create genetically uniform populations that
survive in habitat cells but not matrix cells. However, these same
defaults typically produce extinction in continuous landscapes where
exact environmental matches are rare. As a consequence, explicit
genetic_params specification is essential when working with continuous
environmental gradients (demonstrated in the Main Analysis below).

The `simulation_params` list controls simulation duration through
`max_events` (maximum number of demographic events). The `master_seed`
ensures reproducibility: identical parameters and seed produce identical
results, while different seeds produce independent stochastic iterations.
Note that exact reproducibility also requires the same TWoLife and R
versions.

## Simulation Output

Simulations return a list object containing four components that provide
different levels of detail about population outcomes. This structure
balances the need for quick summaries (summary component), detailed
individual-level data (survivors component), complete demographic
records (events component), and reproducibility (parameters component):

-   **`summary`**: A list of final population statistics including
    `final_population_size` (number surviving at simulation end),
    `total_births` (cumulative birth events), `total_deaths` (cumulative
    death events), `total_dispersals` (cumulative dispersal events), and
    `final_time` (simulation duration). This component provides quick
    assessment of population outcomes without requiring data processing.

-   **`survivors`**: A data frame where each row represents one
    surviving individual at simulation end. Columns include
    `individual_id`, `genotype` (genotype_mean value), `genotype_sd`
    (niche width), `phenotype` (expressed environmental optimum), `x`
    and `y` (spatial coordinates). This component enables analysis of
    trait distributions, spatial patterns, and phenotype-environment
    matching among survivors. When populations go extinct, this
    component may be NULL or an empty dataframe.

-   **`events`**: A data frame recording every demographic event that
    occurred during the simulation. The level of detail depends on the
    `history_detail` parameter (set in `simulation_params`). At minimum
    (`history_detail="minimal"`), each row documents one event with
    columns: `time` (when event occurred), `event_type` (0=death,
    1=birth, 2=dispersal, 3=emigration, -1=initial state), and
    `individual_id`. Standard detail (`history_detail="standard"`, the
    default) additionally includes `patch_id`, `x` and `y` coordinates,
    and `genotype`. Full detail (`history_detail="full"`) further adds
    `phenotype` and `width` (genotype_sd). This complete history enables
    analysis of population dynamics, demographic rates over time, and
    lineage tracking.

-   **`parameters`**: A list storing all input parameters
    (landscape_params, individual_params, genetic_params,
    simulation_params, master_seed). This ensures complete
    reproducibility—simulations can be exactly replicated by re-running
    with stored parameters. It also enables systematic comparison across
    simulations with different parameter configurations.

# Main Analysis: Individual Variation in Heterogeneous Environments

TWoLife’s distinguishing capability is modeling populations where
individual fitness emerges from phenotype–environment matching along
continuous environmental gradients, rather than being pre-assigned by
habitat type. This section demonstrates that capability through a
controlled comparison of five scenarios that differ only in which
individual-level mechanisms are active, holding all other conditions
constant (landscape structure, initial population size, simulation
duration, and random seeds).

The scenarios progressively add mechanisms: genetic diversity in optimal
trait values, tolerance (niche width), evolutionary processes (mutation
and plasticity), and habitat selection behavior. This progression allows
each mechanism’s contribution to be read off directly from the change in
population outcome between adjacent scenarios, and tests whether
mechanisms interact additively or synergistically.

## Landscape and Experimental Design

We generate the continuous landscape shared by all five scenarios:

```{r continuous-landscape}
set.seed(50)
continuous_landscape <- create_fractal_landscape(
  cells_per_row = 5,             # 5×5 = 25 total cells
  fractality = 0.5,              # Balanced spatial autocorrelation
  min_value = 0.0,               # Minimum environmental value
  max_value = 100.0              # Maximum environmental value
)
```

The resulting 25-cell (5×5) landscape spans values from 0.0 to 100.0
with intermediate-scale spatial structure (fractality=0.5). No cell is
inherently suitable or unsuitable—suitability depends entirely on
phenotype–environment matching, as established in Key Concepts.

```{r visualize-continuous, fig.width=5, fig.height=4.5, echo=FALSE}
plot_landscape(continuous_landscape,
                            main = "Continuous Environmental Landscape\n(fractality = 0.5)",
                            colors = "terrain")
```

The visualization uses a terrain color scheme where cooler colors
(blues, greens) represent low environmental values and warmer colors
(yellows, reds) represent high values. Observe the intermediate-scale
patchiness created by fractality=0.5—some clustering of similar values
occurs (e.g., contiguous blue regions in lower-left, yellow regions in
upper-right), but substantial variation exists throughout the landscape.

We implement five scenarios that differ only in genetic parameters, with
all other conditions held constant. This factorial design allows us to
isolate each mechanism's contribution to population outcomes. The order
of mechanism addition follows a biological hierarchy from fundamental to
facultative: (1) genetic diversity in optimal values is the most basic
requirement—populations need variation to span environmental gradients;
(2) tolerance (niche width) enables each genotype to survive across a
range of conditions rather than requiring exact matches; (3) evolution
(mutation + plasticity) allows populations to generate new variation and
fine-tune existing variation through natural selection; (4) behavior
(habitat selection) enables individuals to actively locate suitable
habitats rather than dispersing randomly:

| Scenario | Genetic Diversity | Niche Width | Evolution | Behavior | Configuration |
|------------|------------|------------|------------|------------|------------|
| 1\. Uniform specialists | No (all genotype=1.0) | No (sds=0) | No | No | Default parameters |
| 2\. Variable specialists | Yes (genotypes 0–100) | No (sds=0) | No | No | genotype_means only |
| 3\. Generalists | Yes | **Yes (sds=0.4)** | No | No | Add genotype_sds |
| 4\. Evolution | Yes | Yes | **Yes** (mutation + plasticity) | No | Add mutation, plasticity |
| 5\. Habitat selection | Yes | Yes | Yes | **Yes** (sampling=10) | Add sampling_points, temperature |

All scenarios use identical conditions except genetic parameters: same
landscape (continuous_landscape generated above), same initial
population size (N=1000, supersaturated relative to landscape carrying capacity), and same
simulation duration (100 demographic events, chosen to be
computationally lightweight while still revealing which mechanisms
enable persistence).

Before running the scenarios we define all shared parameters exactly once:

```{r shared-params}
# ── Population size and initial genotypes ────────────────────────────────────
# Uniformly-spaced genotypes span the full environmental gradient (0–100)
# so that each of the 1 000 individuals begins with a distinct optimum.
# Using a deterministic sequence (rather than random draws) ensures that
# genetic composition is identical across scenarios 2–5.
initial_pop_size  <- 1000
initial_genotypes <- seq(0, 100, length.out = initial_pop_size)

# ── Shared landscape parameters ──────────────────────────────────────────────
# All five scenarios run on the same landscape with the same configuration.
shared_landscape_params <- list(
  habitat                     = continuous_landscape,
  cell_size                   = 1.0,
  boundary_condition          = 1,     # reflective: individuals bounce off borders
  density_type                = 1,     # local density within neighbor_radius
  matrix_mortality_multiplier = 2.0,   # μ_max = 2 × μ_min = 0.4
  matrix_dispersal_multiplier = 0.5
)

# ── Shared individual parameters ─────────────────────────────────────────────
# Demographic rates and movement geometry are identical across scenarios.
shared_individual_params <- list(
  initial_population_size = initial_pop_size,
  neighbor_radius         = 2.0,
  vision_angle            = pi,
  step_length             = 5.0,
  base_dispersal_rate     = 0.4,
  base_birth_rate         = 0.6,
  base_mortality_rate     = 0.2,
  birth_density_slope     = 0.02,
  mortality_density_slope = 0.02
)

# ── Shared simulation parameters ─────────────────────────────────────────────
# 100 demographic events per scenario — the smaller 5×5 landscape keeps
# runtimes short while providing enough time to distinguish the five
# ecological strategies.
shared_simulation_params <- list(max_events = 100)
```

## Scenario 1: Uniform Perfect Specialists

This scenario demonstrates default behavior when `genetic_params` is
omitted: all individuals are genetically identical with genotype_mean=1.0
and genotype_sd=0.

```{r scenario1}
# Only genetic_params is omitted — every other argument comes from the
# shared lists defined above.  This makes the scenario's distinctive
# choice (no genetic variation) immediately visible.
sim_s1 <- twolife_simulation(
  landscape_params  = shared_landscape_params,
  individual_params = shared_individual_params,
  # genetic_params omitted → defaults: all genotype_mean = 1.0, genotype_sd = 0
  simulation_params = shared_simulation_params,
  master_seed = 45
)

(pop_s1 <- sim_s1$summary$final_population_size)
```

The simulation results in N = `r pop_s1` (extinction). Zero tolerance
(`genotype_sd = 0`) means individuals require exact environmental
matches that probably do not exist in the continuous landscape (range:
`r sprintf("%.2f", min(continuous_landscape))` to
`r sprintf("%.2f", max(continuous_landscape))`). Starting with
genotype_mean = 1.0, only cells with exactly that environmental value
produce minimum mortality—any other value produces maximum
mortality—demonstrating that genetic uniformity combined with specialist
strategies is incompatible with persistence in heterogeneous continuous
environments.

## Scenario 2: Variable Specialists

This scenario adds genetic diversity: each of the 1000 individuals has a
distinct genotype_mean spanning 0 to 100, but genotype_sd remains 0
(perfect specialists still requiring exact environmental matches).

```{r scenario2}
# Adding genotype_means is the only change from Scenario 1.
# genotype_sds still defaults to 0 (perfect specialists).
sim_s2 <- twolife_simulation(
  landscape_params  = shared_landscape_params,
  individual_params = shared_individual_params,
  genetic_params = list(
    genotype_means = initial_genotypes   # 1 000 distinct optima spanning 0–100
    # genotype_sds defaults to 0 → perfect specialists, no tolerance
  ),
  simulation_params = shared_simulation_params,
  master_seed = 46
)

(pop_s2 <- sim_s2$summary$final_population_size)
```

The simulation results in N = `r pop_s2` (extinction). Despite having
1000 different genotypes spanning the full environmental range (0–100),
zero tolerance means individuals still require exact environmental
matches. In continuous space, exact matches rarely occur—even if an
individual has `genotype_mean = 5.0` and a cell has `environment = 5.0`,
any slight mismatch produces effectively zero fitness when
`genotype_sd = 0`. This demonstrates that genetic diversity alone is
insufficient without tolerance enabling survival across a range of
conditions.

## Scenario 3: Generalists (Niche Width)

This example demonstrates the effect of adding tolerance (genotype_sd).
Each individual has the same genotype_mean as Scenario 2 (maintaining
identical genetic diversity), but now with genotype_sd=0.4, enabling
survival across a small range of conditions around their optima.

```{r scenario3}
# Only genetic_params changes from S2: genotype_sds is now 0.4.
# landscape, individual, and simulation arguments are inherited unchanged.
sim_s3 <- twolife_simulation(
  landscape_params  = shared_landscape_params,
  individual_params = shared_individual_params,
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds   = rep(0.4, initial_pop_size)   # key change: add niche width
    # mutation_rates  defaults to 0 → no evolution
    # plasticities    defaults to 0 → no phenotypic noise
    # sampling_points defaults to 0 → random walk dispersal
  ),
  simulation_params = shared_simulation_params,
  master_seed = 47
)

(pop_s3 <- sim_s3$summary$final_population_size)
```

The simulation results in N = `r pop_s3`
(`r sprintf("%.1f%%", pop_s3/initial_pop_size*100)` survival), compared
to N=0 in Scenarios 1-2. Adding tolerance enables population persistence
by allowing individuals to survive in cells where their phenotype does
not exactly match the local environment. With genotype_sd=0.4 (just
above $\sigma_{min} \approx 0.3989$), individuals achieve near-maximum
peak fitness at their optimum with a very steep fitness decline away
from it — niche width covers only $\approx 0.4$% of the 0–100
environmental range, so individuals are genuinely narrow specialists.
This tolerance interacts with genetic diversity: because different
individuals have different optima spanning 0 to 100, collectively they
can utilize the full environmental gradient.

Survivor genotype distribution reveals which individuals persisted:

```{r scenario3-analysis}
# Examine survivor trait distribution
if (pop_s3 > 0) {
  survivor_summary <- c(
    Mean_genotype = mean(sim_s3$survivors$genotype),
    SD_genotype = sd(sim_s3$survivors$genotype),
    Range = paste0("[", sprintf("%.2f", min(sim_s3$survivors$genotype)),
                   ", ", sprintf("%.2f", max(sim_s3$survivors$genotype)), "]")
  )
  survivor_summary
}
```

## Scenario 4: Evolution (Mutation + Plasticity)

This example demonstrates adding evolutionary mechanisms (mutation and
plasticity) to the diversity and tolerance from Scenario 3. Mutation
(mutation_rate=0.001) enables heritable genetic change across
generations, while plasticity (plasticity=0.001) enables non-heritable
phenotypic variation within lifetimes.

```{r scenario4}
# Two parameters added to S3's genetic_params: mutation_rates and plasticities.
# All other arguments are unchanged.
sim_s4 <- twolife_simulation(
  landscape_params  = shared_landscape_params,
  individual_params = shared_individual_params,
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds   = rep(0.4,   initial_pop_size),
    mutation_rates = rep(0.001, initial_pop_size),   # heritable variation across generations
    plasticities   = rep(0.001, initial_pop_size)    # non-heritable phenotypic noise
    # sampling_points defaults to 0 → random walk dispersal still
  ),
  simulation_params = shared_simulation_params,
  master_seed = 48
)

(pop_s4 <- sim_s4$summary$final_population_size)
(delta_evolution <- pop_s4 - pop_s3)
```

The simulation results in N = `r pop_s4` (change: `r delta_evolution`
from Scenario 3). This scenario instantiates eco-evolutionary dynamics:
mutation and plasticity operate on the same timescale as demographic
events, so evolutionary change and population persistence are
inseparable processes [@Hairston2005; @Schoener2011]. Whether this rapid evolution
prevents extinction — an instance of evolutionary rescue — depends on
whether genetic variation can be generated and selected fast enough to
track the heterogeneous environment [@Bell2009]. Mutation allows the
population to explore genetic space beyond the initial genotype
distribution (0–100), potentially adapting to local environmental
conditions if selection favors particular genotypes. Plasticity allows
phenotypes to deviate from genotypes, which can be beneficial if it
increases variance in trait-environment matching, though it can also be
detrimental if it moves phenotypes away from local optima. The net
effect depends on the balance between these processes over the
simulation duration.

## Scenario 5: Habitat Selection (Behavioral Optimization)

This example demonstrates adding habitat selection behavior
(sampling_points=10) to all mechanisms from Scenario 4. Individuals
evaluate 10 potential dispersal locations and preferentially select
high-fitness sites through softmax weighting with temperature=0.1. Lower
temperature values sharpen the softmax preference toward the best
available location; at 0.1, selection is fairly strong while retaining
some stochasticity.

```{r scenario5}
# Two parameters added to S4's genetic_params: sampling_points and temperatures.
# The pattern is now clear: each scenario extends the previous genetic_params
# by adding one new mechanism, while shared parameters remain untouched.
sim_s5 <- twolife_simulation(
  landscape_params  = shared_landscape_params,
  individual_params = shared_individual_params,
  genetic_params = list(
    genotype_means                 = initial_genotypes,
    genotype_sds                   = rep(0.4,   initial_pop_size),
    mutation_rates                 = rep(0.001, initial_pop_size),
    plasticities                   = rep(0.001, initial_pop_size),
    sampling_points                = rep(10,    initial_pop_size),   # evaluate 10 candidate sites
    habitat_selection_temperatures = rep(0.1,   initial_pop_size)    # strong softmax preference
  ),
  simulation_params = shared_simulation_params,
  master_seed = 49
)

(pop_s5 <- sim_s5$summary$final_population_size)
(delta_behavior <- pop_s5 - pop_s4)
(cumulative_gain <- pop_s5 - pop_s2)
```

The simulation results in N = `r pop_s5` (change: `r delta_behavior`
from Scenario 4). Habitat selection added complexity beyond the effects
of evolution and tolerance. Cumulatively, tolerance was the critical
transition that enabled population persistence, while evolution
introduced sources of variation that alone could be detrimental. Habitat
selection allows individuals to actively seek favorable environmental
conditions, thereby decoupling where an individual lands from where it
ultimately survives [@Ravigne2009].

## Comparative Analysis

The table below summarizes population outcomes across all five
scenarios. The "Change" column shows each mechanism's incremental
contribution, revealing relative importance and potential interaction
effects:

```{r comparative-summary}
# Summary table showing progressive mechanism effects
results_summary <- data.frame(
  Scenario = c("S1: Uniform", "S2: Diversity", "S3: Tolerance",
               "S4: Evolution", "S5: Behavior"),
  Final_N = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
  Change = c("—",
             sprintf("%+d", pop_s2 - pop_s1),
             sprintf("%+d", pop_s3 - pop_s2),
             sprintf("%+d", pop_s4 - pop_s3),
             sprintf("%+d", pop_s5 - pop_s4)),
  Mechanism_Added = c("None (baseline)",
                      "Genetic diversity in optima",
                      "Tolerance (niche width)",
                      "Mutation + plasticity",
                      "Habitat selection")
)
results_summary
```

The figure below shows population trajectories over time (left panel)
and final population sizes (right panel) across scenarios. Note that
Scenarios 1-2 (red bars, extinct) differ fundamentally from Scenarios
3-5 (green bars, viable), suggesting tolerance is a critical threshold
parameter. The trajectory panel reveals temporal dynamics: Scenario 3
shows initial decline then stabilization (demographic adjustment to
carrying capacity), while Scenarios 4-5 show
`r ifelse(pop_s4 > pop_s3 | pop_s5 > pop_s4, "enhanced dynamics", "similar patterns")`
from evolutionary and behavioral mechanisms. All scenarios started with
N=`r initial_pop_size` (black horizontal line in left panel):

```{r comparative-visualization, fig.width=9, fig.height=4.5, echo=FALSE}
par(mfrow = c(1, 2), mar = c(5, 4, 3, 2))

# Extract population trajectories for viable scenarios
traj_s3 <- population_size(sim_s3)
traj_s4 <- population_size(sim_s4)
traj_s5 <- population_size(sim_s5)

# Population dynamics over time (only viable scenarios shown)
# ylim is computed from the actual data range so the trajectories fill the panel.
# A small margin (5%) is added above and below to avoid clipping.
all_pops <- c(traj_s3$population_size, traj_s4$population_size, traj_s5$population_size)
min_pop  <- min(all_pops)
max_pop  <- max(all_pops)
pop_pad  <- (max_pop - min_pop) * 0.05   # 5% of the observed range as padding
plot(traj_s3$time, traj_s3$population_size, type = "l", col = "blue", lwd = 2,
     main = "Population Trajectories\n(Viable Scenarios Only)",
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(max(0, min_pop - pop_pad), max_pop + pop_pad))
lines(traj_s4$time, traj_s4$population_size, col = "darkgreen", lwd = 2)
lines(traj_s5$time, traj_s5$population_size, col = "purple", lwd = 2)
abline(h = initial_pop_size, lty = 1, col = "black", lwd = 1.5)
text(max(traj_s3$time)*0.02, initial_pop_size, paste0("Initial N=", initial_pop_size), pos = 3, cex = 0.9, font = 2)
legend("topright", legend = c("S3: Tolerance", "S4: Evolution", "S5: Behavior"),
       col = c("blue", "darkgreen", "purple"), lwd = 2, bty = "n", cex = 0.85)

# Final population sizes (all scenarios) with unified colors
final_pops <- c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5)
bar_colors <- c("red", "red", "blue", "darkgreen", "purple")  # match trajectory colors
bp <- barplot(final_pops,
              names.arg = c("S1", "S2", "S3", "S4", "S5"),
              main = "Final Population Sizes\n(Red=Extinct, Colored=Viable)",
              ylab = "Population Size (N)",
              col = bar_colors,
              las = 1,
              ylim = c(0, max(final_pops) * 1.15))  # extra space for labels

# Add text labels above bars
text(x = bp, 
     y = final_pops + max(final_pops)*0.03,
     labels = final_pops,
     cex = 1.1, font = 2)
abline(h = 0, lwd = 0.5)
```

## Verifying Phenotype-Environment Matching

The check_habitat_match() function visualizes phenotype–environment
alignment by comparing survivor trait values with their occupied
locations. It produces two panels: the landscape colored by
environmental values (left) and survivor positions colored by phenotype
or genotype values (right). Both panels share the same color scale.
Effective matching is indicated when survivor dots visually “blend” with
the underlying landscape gradient.

Scenario 3 (Tolerance only): Without evolution or active habitat
selection, matching arises solely through differential survival. Poorly
matched individuals die, leaving survivors in locations where their
traits happen to fit. This passive filtering produces moderate spatial
structure.

```{r validation-s3, fig.width=8, fig.height=4}

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))

if (pop_s3 > 0) {
  check_habitat_match(sim_s3,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

Plots show survivors generally occupying regions matching their
phenotypes, demonstrating that differential survival alone can produce
reasonable phenotype–environment alignment.

**Scenario 4 (Evolution added):** Mutation allows gradual shifts in
genotype toward better local adaptation. Over the short simulation (100
events), changes are subtle, so the primary mechanism remains
differential survival. Any improvement is seen as slightly tighter
alignment between survivor traits and local environmental values.

```{r validation-s4, fig.width=8, fig.height=4}
par(mfrow = c(1, 1))
if (pop_s4 > 0) {
  check_habitat_match(sim_s4,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

Plots resemble Scenario 3, with enhancements indicating subtle
evolutionary adjustments.

**Scenario 5 (Habitat selection added):** Active habitat selection
produces the strongest matching. Individuals evaluate multiple locations
(`sampling_points=10`) and preferentially settle where their phenotype
aligns with the local environment, guided by the softmax function with
temperature=0.1.

```{r validation-s5, fig.width=8, fig.height=4}
par(mfrow = c(1, 1))
if (pop_s5 > 0) {
  check_habitat_match(sim_s5,
                           color_by = "phenotype",
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = TRUE)
}
```

Plots show clear spatial segregation, with survivor dots closely aligned
to the landscape gradient, demonstrating successful selection.

# Computational Considerations

## Performance Scaling

TWoLife's computational cost is dominated by neighbor calculations that
occur during each demographic event (birth, death, dispersal).
Understanding these scaling relationships helps in designing feasible
simulation experiments:

-   **Population size**: Cost scales **quadratically** (O(N²)) with
    population size because each event requires updating neighbor lists
    (O(N) operation), and larger populations generate proportionally
    more events. Doubling population size increases runtime
    approximately 4-fold.

-   **Landscape size**: Indirectly affects cost through carrying
    capacity. Larger landscapes support proportionally more individuals
    at equilibrium (density = N/area). Doubling landscape dimensions
    increases area 4-fold, supporting \~4× more individuals, which
    increases cost \~16-fold due to O(N²) scaling.

-   **Habitat selection**: Cost scales linearly with `sampling_points`.
    Use sampling_points=1 for exploration, 10-100 when habitat selection
    mechanisms are scientifically important.

-   **Simulation duration**: Cost scales linearly with `max_events`.

**Recommendation:** Start with smaller simulations (15-30 cell
landscapes, N = 40-100, sampling_points = 1) for parameter exploration.
Scale up cautiously, recognizing that doubling landscape dimensions
costs \~16× more computation.

## Memory Usage

Memory usage scales linearly with simulation duration because TWoLife
stores complete event histories. Each event requires approximately
200-500 bytes depending on genetic architecture, so a simulation with
10,000 events requires roughly 2-5 MB. Memory is not a limiting factor
for most applications, but for extremely long simulations (\>1 million
events), monitor memory usage.

# References

::: {#refs}
:::
